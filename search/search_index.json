{
    "docs": [
        {
            "location": "/", 
            "text": "Just-API\n\n\nJust-API is a declarative, specification based test framework for \nREST\n, \nGraphQL\n (or any HTTP-based) APIs. Users can test APIs without writing code, but they can also tap into code when they want to. It reads API test specification from YAML files and runs them in serial/parallel mode. Test reports can be generated in several formats including HTML and JSON.\n\n\n\nIn simple terms, users build a test suite by providing a set of request and response validation specification in a YAML file. Each suite can have one or more specs. Just-API builds the request, sends it to server and validates response as per the specification.\nOne can choose to validate any or all of following\n\n\n\n\nResponse Status code\n\n\nResponse Headers\n\n\nResponse JSON body\n\n\nResponse JSON schema\n\n\n\n\nor Provide a custom Javascript function to validate the response\n\n\nContents\n\n\nDocumentation\n\n\n\n\nGetting Started\n\n\nBasic Concepts\n\n\nCLI\n\n\nFeatures\n\n\nReporters\n\n\nExamples\n\n\n\n\nFind it on npm\n\n\n\n\nStay In Touch\n\n\n     \n\n\nIf you are having problems with Just-API, or have a question, chat with the community on gitter.\n\n\n\n\nJust-API Google group", 
            "title": "Home"
        }, 
        {
            "location": "/#just-api", 
            "text": "Just-API is a declarative, specification based test framework for  REST ,  GraphQL  (or any HTTP-based) APIs. Users can test APIs without writing code, but they can also tap into code when they want to. It reads API test specification from YAML files and runs them in serial/parallel mode. Test reports can be generated in several formats including HTML and JSON.  In simple terms, users build a test suite by providing a set of request and response validation specification in a YAML file. Each suite can have one or more specs. Just-API builds the request, sends it to server and validates response as per the specification.\nOne can choose to validate any or all of following   Response Status code  Response Headers  Response JSON body  Response JSON schema   or Provide a custom Javascript function to validate the response", 
            "title": "Just-API"
        }, 
        {
            "location": "/#contents", 
            "text": "", 
            "title": "Contents"
        }, 
        {
            "location": "/#documentation", 
            "text": "Getting Started  Basic Concepts  CLI  Features  Reporters  Examples", 
            "title": "Documentation"
        }, 
        {
            "location": "/#find-it-on-npm", 
            "text": "", 
            "title": "Find it on npm"
        }, 
        {
            "location": "/#stay-in-touch", 
            "text": "If you are having problems with Just-API, or have a question, chat with the community on gitter.   Just-API Google group", 
            "title": "Stay In Touch"
        }, 
        {
            "location": "/getting-started/", 
            "text": "Installation\n\n\nInstall with \nnpm\n:\n\n\nnpm install just-api\n\n\n\n\n\n\n\nNote\n\n\nTo run just-api, you will need Node.js v7.10.0 or newer.\n\n\n\n\nGetting Started\n\n\nmkdir specs\n\n\n\n\n\nvim specs/starwars_service.yml\n\n\n\n\n\nEnter below specification in YAML file\n\n\nmeta\n:\n\n  \nname\n:\n \nStar\n \nWars\n \nsuite\n\n\nconfiguration\n:\n\n  \nscheme\n:\n \nhttps\n\n  \nhost\n:\n \nswapi.co\n\n  \nbase_path\n:\n \n/api\n\n\nspecs\n:\n\n  \n-\n \nname\n:\n \nget\n \nLuke\n \nSkywalker\n \ninfo\n\n    \nrequest\n:\n\n      \npath\n:\n \n/people/1/\n\n      \nmethod\n:\n \nget\n\n    \nresponse\n:\n\n      \nstatus_code\n:\n \n200\n\n      \nheaders\n:\n\n        \n-\n \nname\n:\n \ncontent-type\n\n          \nvalue\n:\n \n!!js/regexp\n \napplication/json\n      \n      \njson_data\n:\n\n        \n-\n \npath\n:\n \n$.name\n\n          \nvalue\n:\n \nLuke\n \nSkywalker\n\n\n\n\n\n\nBack in the terminal\n\n\n$ ./node_modules/.bin/just-api\n\n   \u2713 get Luke Skywalker info (1216ms)\n\n  Done: specs/starwars_service.yml (Passed)\n\n0 skipped, 0 failed, 1 passed (1 tests)\n0 skipped, 0 failed, 1 passed (1 suites)\nDuration: 1.3s\n\n\n\n\n\nTesting GraphQL APIs\n\n\nFollowing example tests a GraphQL API that returns location for a given ip address.\n\n\nCreate a YAML suite and run just-api.\n\n\nmeta\n:\n\n  \nname\n:\n \nGraphQL location service\n\n\nconfiguration\n:\n\n  \nhost\n:\n \napi.graphloc.com\n\n  \nscheme\n:\n \nhttps\n\n\nspecs\n:\n\n  \n-\n \nname\n:\n \nGet Location of a given ip address\n\n    \nrequest\n:\n\n      \nmethod\n:\n \npost\n\n      \npath\n:\n \n/graphql\n\n      \nheaders\n:\n\n        \n-\n \nname\n:\n \ncontent-type\n\n          \nvalue\n:\n \napplication/json\n\n      \npayload\n:\n\n        \nbody\n:\n\n          \ntype\n:\n \njson\n\n          \ncontent\n:\n\n            \nquery\n:\n \n\n                   \n{\n\n                    \ngetLocation(ip: \n8.8.8.8\n) {\n\n                      \ncountry {\n\n                        \niso_code\n\n                      \n}\n\n                     \n}\n\n                    \n}\n\n            \nvariables\n:\n \nnull\n\n            \noperationName\n:\n \nnull\n\n    \nresponse\n:\n\n      \nstatus_code\n:\n \n200\n\n      \njson_data\n:\n\n        \n-\n \npath\n:\n \n$.data.getLocation.country.iso_code\n\n          \nvalue\n:\n \nUS\n\n\n\n\n\n\nA chained request flow with hook and custom validation\n\n\nWhen you need to test complex chained API flows, run dependencies in hooks to fetch pre-requisite data \nand pass it to actual test.\n\n\nFollowing example shows how to run dependencies using a hook, get data and validating response with a custom validator function.\n\n\nmeta\n:\n\n  \nname\n:\n \nStarwars suite\n\n\nconfiguration\n:\n\n  \nscheme\n:\n \nhttps\n\n  \nhost\n:\n \nswapi.co\n\n  \nbase_path\n:\n \n/api\n\n\nspecs\n:\n\n  \n-\n \nname\n:\n \nget R2-D2 info\n\n    \nrequest\n:\n\n      \npath\n:\n \n/people/3/\n\n      \nmethod\n:\n \nget\n\n    \nresponse\n:\n\n      \nstatus_code\n:\n \n200\n\n      \njson_data\n:\n\n        \n-\n \npath\n:\n \n$.name\n\n          \nvalue\n:\n \nR2-D2\n\n\n  \n-\n \nname\n:\n \nsearch R2-D2 info\n\n    \nbefore_test\n:\n\n      \nrun_type\n:\n \ninline\n\n      \ninline\n:\n\n        \nfunction\n:\n \n!js/asyncFunction\n \n\n          \nasync function() {\n\n            \nvar response = await this.runSpec(\nget R2-D2 info\n);\n\n            \nvar jsonData = JSON.parse(response.body);\n\n            \nthis.test.query_params = { name:  jsonData.name };\n\n          \n}\n\n    \nrequest\n:\n\n      \npath\n:\n \n/people\n\n      \nmethod\n:\n \nget\n\n    \nresponse\n:\n\n      \nstatus_code\n:\n \n200\n\n      \ncustom_validator\n:\n\n        \nrun_type\n:\n \ninline\n\n        \ninline\n:\n\n          \nfunction\n:\n \n!!js/function\n \n\n            \nfunction() {\n\n              \nvar jsonData = JSON.parse(this.response.body);\n\n              \nvar r2d2 = jsonData.results.find(result =\n result.name === \nR2-D2\n);\n\n\n              \nif (!r2d2) throw new Error(\nR2-D2 not returned in search results\n);\n\n            \n}\n\n\n\n\n\n\n\n\nNote\n\n\nYou can also place custom JS functions in a module and specify the function name and path to module in YAML.\n\n\n\n\nUsing docker to run Just-API tests\n\n\nIf you are looking to use Docker to run Just-API, you might want to checkout\nJust-API docker boilerplate \nhere", 
            "title": "Getting Started"
        }, 
        {
            "location": "/getting-started/#installation", 
            "text": "Install with  npm :  npm install just-api   Note  To run just-api, you will need Node.js v7.10.0 or newer.", 
            "title": "Installation"
        }, 
        {
            "location": "/getting-started/#getting-started", 
            "text": "mkdir specs  vim specs/starwars_service.yml  Enter below specification in YAML file  meta : \n   name :   Star   Wars   suite  configuration : \n   scheme :   https \n   host :   swapi.co \n   base_path :   /api  specs : \n   -   name :   get   Luke   Skywalker   info \n     request : \n       path :   /people/1/ \n       method :   get \n     response : \n       status_code :   200 \n       headers : \n         -   name :   content-type \n           value :   !!js/regexp   application/json       \n       json_data : \n         -   path :   $.name \n           value :   Luke   Skywalker   Back in the terminal  $ ./node_modules/.bin/just-api\n\n   \u2713 get Luke Skywalker info (1216ms)\n\n  Done: specs/starwars_service.yml (Passed)\n\n0 skipped, 0 failed, 1 passed (1 tests)\n0 skipped, 0 failed, 1 passed (1 suites)\nDuration: 1.3s", 
            "title": "Getting Started"
        }, 
        {
            "location": "/getting-started/#testing-graphql-apis", 
            "text": "Following example tests a GraphQL API that returns location for a given ip address.  Create a YAML suite and run just-api.  meta : \n   name :   GraphQL location service  configuration : \n   host :   api.graphloc.com \n   scheme :   https  specs : \n   -   name :   Get Location of a given ip address \n     request : \n       method :   post \n       path :   /graphql \n       headers : \n         -   name :   content-type \n           value :   application/json \n       payload : \n         body : \n           type :   json \n           content : \n             query :   \n                    { \n                     getLocation(ip:  8.8.8.8 ) { \n                       country { \n                         iso_code \n                       } \n                      } \n                     } \n             variables :   null \n             operationName :   null \n     response : \n       status_code :   200 \n       json_data : \n         -   path :   $.data.getLocation.country.iso_code \n           value :   US", 
            "title": "Testing GraphQL APIs"
        }, 
        {
            "location": "/getting-started/#a-chained-request-flow-with-hook-and-custom-validation", 
            "text": "When you need to test complex chained API flows, run dependencies in hooks to fetch pre-requisite data \nand pass it to actual test.  Following example shows how to run dependencies using a hook, get data and validating response with a custom validator function.  meta : \n   name :   Starwars suite  configuration : \n   scheme :   https \n   host :   swapi.co \n   base_path :   /api  specs : \n   -   name :   get R2-D2 info \n     request : \n       path :   /people/3/ \n       method :   get \n     response : \n       status_code :   200 \n       json_data : \n         -   path :   $.name \n           value :   R2-D2 \n\n   -   name :   search R2-D2 info \n     before_test : \n       run_type :   inline \n       inline : \n         function :   !js/asyncFunction   \n           async function() { \n             var response = await this.runSpec( get R2-D2 info ); \n             var jsonData = JSON.parse(response.body); \n             this.test.query_params = { name:  jsonData.name }; \n           } \n     request : \n       path :   /people \n       method :   get \n     response : \n       status_code :   200 \n       custom_validator : \n         run_type :   inline \n         inline : \n           function :   !!js/function   \n             function() { \n               var jsonData = JSON.parse(this.response.body); \n               var r2d2 = jsonData.results.find(result =  result.name ===  R2-D2 ); \n\n               if (!r2d2) throw new Error( R2-D2 not returned in search results ); \n             }    Note  You can also place custom JS functions in a module and specify the function name and path to module in YAML.", 
            "title": "A chained request flow with hook and custom validation"
        }, 
        {
            "location": "/getting-started/#using-docker-to-run-just-api-tests", 
            "text": "If you are looking to use Docker to run Just-API, you might want to checkout\nJust-API docker boilerplate  here", 
            "title": "Using docker to run Just-API tests"
        }, 
        {
            "location": "/basic-concepts/", 
            "text": "Basic Concepts\n\n\nThis section covers some high level basic concepts that are important to understand for day to day Just-API usage. We highly recommend that you read this page before proceeding to use Just-API.\n\n\nThe High-level View\n\n\nJust-API's main purpose is to test HTTP-based APIs without code, and make API testing easy, free and fast for everyone.\n\n\nWrite your API test specification and tell Just-API to run them. API test specification is written in YAML and we call each YAML file a test suite, with the option to write Javascript (using any \nnpm\n module if needed) to implement custom logic.\n\n\nJust-API is written with parallelism as high priority when running test suites, so your test execution takes as less time as possible.\n\n\nPutting a test suite together\n\n\nA test suite has three required sections - \nmeta\n, \nconfiguration\n and \nspecs\n.\n\n\nAnd optional sections \nhooks\n and \nspec_dependencies\n (you can find more about these optional parts in later sections of the documentation).\n\n\nThe \nmeta\n Section\n\n\nSpecify following suite attributes in this section\n\n\n\n\nname\n (\nrequired attribute\n)\n\n\nlocate_files_relative\n (\noptional attribute\n)\n\n\n\n\nname\n[String]: Give a name that describes the suite (e.g: like a microservice name)\n\n\nlocate_files_relative\n[Boolean]: Tells Just-API if file paths provided in the suite are relative to suite path or not. If false, Just-API will try to find files relative to Node process's current working directory.\nIf true, Just-API will try to find files relative to the suite's path.\nDefault value is false.\n\n\nNote: This attribute value applies to every file path you provide in a suite.\n\n\nThe \nconfiguration\n Section\n\n\nYou can use \nconfiguration\n section to specify API's host, protocol, port etc. You can also provide a custom Javascript function to \ncustom_configuration\n attribute, so it's easy to \ndynamically configure your suite at runtime.\n\n\nThe \nspecs\n Section\n\n\nspecs\n section is a list of tests. Each test contains name, request, response validation specification, and a few other additional attributes.\n\n\nAn Example Suite\n\n\nA sample suite for Star Wars API service would look like this:\n\n\nmeta\n:\n\n  \nname\n:\n \nStar Wars service\n\n\nconfiguration\n:\n\n  \nscheme\n:\n \nhttps\n\n  \nbase_path\n:\n \n/api\n\n  \ncustom_configuration\n:\n\n    \nrun_type\n:\n \ninline\n\n    \ninline\n:\n\n      \nfunction\n:\n \n!!js/function\n \n\n        \nfunction() {\n\n          \nthis.host = \nswapi.co\n;\n\n        \n}  \n\n\nspecs\n:\n\n  \n-\n \nname\n:\n \nget Luke Skywalker info\n\n    \nrequest\n:\n \n      \npath\n:\n \n/people/1/\n\n      \nmethod\n:\n \nget\n\n    \nresponse\n:\n\n      \nstatus_code\n:\n \n200\n\n      \njson_data\n:\n\n        \n-\n \npath\n:\n \n$.name\n\n          \nvalue\n:\n \nLuke Skywalker\n     \n  \n-\n \nname\n:\n \nget all Star Wars Films\n\n    \nrequest\n:\n \n      \npath\n:\n \n/films/\n   \n      \nmethod\n:\n \nget\n\n    \nresponse\n:\n\n      \nstatus_code\n:\n \n200\n  \n\n\n\n\n\nNext:\n\n\n\n\nSee the full set of features available in \nFeatures\n.\n\n\nLearn about  \nreporters\n in \nReporters\n.", 
            "title": "Basic Concepts"
        }, 
        {
            "location": "/basic-concepts/#basic-concepts", 
            "text": "This section covers some high level basic concepts that are important to understand for day to day Just-API usage. We highly recommend that you read this page before proceeding to use Just-API.", 
            "title": "Basic Concepts"
        }, 
        {
            "location": "/basic-concepts/#the-high-level-view", 
            "text": "Just-API's main purpose is to test HTTP-based APIs without code, and make API testing easy, free and fast for everyone.  Write your API test specification and tell Just-API to run them. API test specification is written in YAML and we call each YAML file a test suite, with the option to write Javascript (using any  npm  module if needed) to implement custom logic.  Just-API is written with parallelism as high priority when running test suites, so your test execution takes as less time as possible.", 
            "title": "The High-level View"
        }, 
        {
            "location": "/basic-concepts/#putting-a-test-suite-together", 
            "text": "A test suite has three required sections -  meta ,  configuration  and  specs .  And optional sections  hooks  and  spec_dependencies  (you can find more about these optional parts in later sections of the documentation).", 
            "title": "Putting a test suite together"
        }, 
        {
            "location": "/basic-concepts/#the-meta-section", 
            "text": "Specify following suite attributes in this section   name  ( required attribute )  locate_files_relative  ( optional attribute )   name [String]: Give a name that describes the suite (e.g: like a microservice name)  locate_files_relative [Boolean]: Tells Just-API if file paths provided in the suite are relative to suite path or not. If false, Just-API will try to find files relative to Node process's current working directory.\nIf true, Just-API will try to find files relative to the suite's path.\nDefault value is false.  Note: This attribute value applies to every file path you provide in a suite.", 
            "title": "The meta Section"
        }, 
        {
            "location": "/basic-concepts/#the-configuration-section", 
            "text": "You can use  configuration  section to specify API's host, protocol, port etc. You can also provide a custom Javascript function to  custom_configuration  attribute, so it's easy to \ndynamically configure your suite at runtime.", 
            "title": "The configuration Section"
        }, 
        {
            "location": "/basic-concepts/#the-specs-section", 
            "text": "specs  section is a list of tests. Each test contains name, request, response validation specification, and a few other additional attributes.", 
            "title": "The specs Section"
        }, 
        {
            "location": "/basic-concepts/#an-example-suite", 
            "text": "A sample suite for Star Wars API service would look like this:  meta : \n   name :   Star Wars service  configuration : \n   scheme :   https \n   base_path :   /api \n   custom_configuration : \n     run_type :   inline \n     inline : \n       function :   !!js/function   \n         function() { \n           this.host =  swapi.co ; \n         }    specs : \n   -   name :   get Luke Skywalker info \n     request :  \n       path :   /people/1/ \n       method :   get \n     response : \n       status_code :   200 \n       json_data : \n         -   path :   $.name \n           value :   Luke Skywalker      \n   -   name :   get all Star Wars Films \n     request :  \n       path :   /films/    \n       method :   get \n     response : \n       status_code :   200     Next:   See the full set of features available in  Features .  Learn about   reporters  in  Reporters .", 
            "title": "An Example Suite"
        }, 
        {
            "location": "/CLI/", 
            "text": "CLI Reference\n\n\nInvoke \njust-api\n from command-line\n\n\nUsage: just-api [options] [files]\n\nOptions:\n\n    -V, --version                       outputs the version number\n    --parallel \ninteger\n                specify the number of suites to be run in parallel\n    --reporter \nreporternames\n          specify the reporters to use, comma separated list e.g json,html\n    --reporter-options \nk=v,k2=v2,...\n  reporter-specific options\n    --grep \npattern\n                    only run tests matching \npattern/string\n\n    --recursive                         include sub directories when searching for suites\n    --reporters                         display available reporters\n    -h, --help                          outputs usage information", 
            "title": "CLI Reference"
        }, 
        {
            "location": "/CLI/#cli-reference", 
            "text": "Invoke  just-api  from command-line  Usage: just-api [options] [files]\n\nOptions:\n\n    -V, --version                       outputs the version number\n    --parallel  integer                 specify the number of suites to be run in parallel\n    --reporter  reporternames           specify the reporters to use, comma separated list e.g json,html\n    --reporter-options  k=v,k2=v2,...   reporter-specific options\n    --grep  pattern                     only run tests matching  pattern/string \n    --recursive                         include sub directories when searching for suites\n    --reporters                         display available reporters\n    -h, --help                          outputs usage information", 
            "title": "CLI Reference"
        }, 
        {
            "location": "/features/", 
            "text": "Just-API Features\n\n\nRequest Specification\n\n\nA typical request specification includes request method, path, headers, query params, path params, and payload (if applicable).\n\n\nRequest Methods\n\n\nJust-API supports following HTTP request methods. You can have a request specification with\nany of these HTTP methods.\n\n\n\n\nGET\n\n\nPOST\n\n\nPUT\n\n\nPATCH\n\n\nDELETE\n\n\nHEAD\n\n\nOPTIONS\n\n\n\n\nSpecifying Headers, Query params, Path params\n\n\nSpecify Request headers to \nheaders\n key as a list of name, value pairs.\n\n\nSpecify Request Query params to \nquery_params\n key as a list of name, value pairs.\n\n\nSpecify Request Path params to \npath_params\n key as a list of name, value pairs.\n\n\n\nA sample test specification with method, headers, query params and path params:\n\n\n  \n-\n \nname\n:\n \nA sample test\n\n    \nrequest\n:\n\n       \npath\n:\n \n/user/{userId}/posts/{postId}\n\n       \nmethod\n:\n \nget\n\n       \nheaders\n:\n\n         \n-\n \nname\n:\n \nAccept\n\n           \nvalue\n:\n \napplication/json\n\n       \npath_params\n:\n\n          \n-\n \nname\n:\n \nuserId\n\n            \nvalue\n:\n \n12876\n\n          \n-\n \nname\n:\n \npostId\n\n            \nvalue\n:\n \n2\n\n       \nquery_params\n:\n\n          \n-\n \nname\n:\n \nlimit\n\n            \nvalue\n:\n \n10\n\n    \nresponse\n:\n\n       \nstatus_code\n:\n \n200\n\n\n\n\n\n\nRequest Body Specification\n\n\nWhen you need to send request body for POST, PUT and PATCH requests, you can specify the body to \npayload\n key.\n\n\nYou will need to specify \ncontent-type\n header and body \ntype\n as shown below\nHere's how to send JSON body with a POST request\n\n\n  \n-\n \nname\n:\n \ncreate a new user\n\n    \nrequest\n:\n \n      \npath\n:\n \n/users\n\n      \nmethod\n:\n \npost\n\n      \nheaders\n:\n\n        \n-\n \nname\n:\n \ncontent-type\n\n          \nvalue\n:\n \napplication/json\n\n      \npayload\n:\n\n          \nbody\n:\n\n            \ntype\n:\n \njson\n\n            \ncontent\n:\n\n              \nfirstName\n:\n \njohn\n\n              \nlastName\n:\n \ndoe\n\n    \nresponse\n:\n\n      \nstatus_code\n:\n \n201\n\n\n\n\n\n\nYou can also send binary data as body from a file as shown below.\n\n\n  \n-\n \nname\n:\n \npost binary data (file) as body\n\n    \nrequest\n:\n\n      \npath\n:\n \n/uploadImage\n\n      \nmethod\n:\n \npost\n\n      \nheaders\n:\n\n        \n-\n \nname\n:\n \ncontent-type\n\n          \nvalue\n:\n \nimage/png\n\n      \npayload\n:\n\n          \nbody\n:\n\n            \ntype\n:\n \nbinary\n \n            \ncontent\n:\n \nstatic/assets/image.png\n \n# Image path\n\n    \nresponse\n:\n\n      \nstatus_code\n:\n \n200\n\n\n\n\n\n\nNote that the image path should be relative to Node process's current working directory or relative to suite's path if you set \nlocate_files_relative\n to true in \nmeta\n section of the suite.\n\n\nCheckout more examples on how to specify request body \nhere\n\n\nx-www-form-urlencoded, Multipart requests, file uploads\n\n\nJust-API supports \nx-www-form-urlencoded\n and \nmultipart/form-data\n requests, using which you can upload files and perform tests on complex requests.\n\n\nspecify \nx-www-form-urlencoded\n request\n\n\nTo create a \nx-www-form-urlencoded\n request test, you will need to specify the \ncontent-type\n header and form body like below:\n\n\nNote that \npayload\n should have a key \nform\n and it should contain form data in key value pairs.\n\n\n  \n-\n \nname\n:\n \nAuthenticate a user\n\n    \nrequest\n:\n\n      \npath\n:\n \n/authenticate\n\n      \nmethod\n:\n \npost\n\n      \nheaders\n:\n\n        \n-\n \nname\n:\n \ncontent-type\n\n          \nvalue\n:\n \napplication/x-www-form-urlencoded\n\n      \npayload\n:\n\n          \nform\n:\n\n            \nuserName\n:\n \njohn.doe\n\n            \npassword\n:\n \njohn.doe.password\n\n    \nresponse\n:\n\n      \nstatus_code\n:\n \n200\n\n\n\n\n\n\nMore examples on \nx-www-form-urlencoded\n tests can be found \nhere\n\n\nspecify \nmultipart/form-data\n request\n\n\nHere's how you can specify a multipart request.\n\n\nNote that \npayload\n should have a key \nform_data\n and it should contain list of form data fields.\n\n\n  \n-\n \nname\n:\n \npost multipart form data - single file and field\n\n    \nrequest\n:\n\n      \npath\n:\n \n/imageNText\n\n      \nmethod\n:\n \npost\n\n      \nheaders\n:\n\n        \n-\n \nname\n:\n \ncontent-type\n\n          \nvalue\n:\n \nmultipart/form-data\n\n      \npayload\n:\n\n          \nform_data\n:\n\n            \n-\n \nname\n:\n \nimage_name\n\n              \ncontent\n:\n \nstatic/assets/logo.png\n \n# file path\n\n              \ntype\n:\n \nfile\n\n            \n-\n \nname\n:\n \nfield1\n\n              \ncontent\n:\n \nvalue1\n\n              \ntype\n:\n \ntext\n\n    \nresponse\n:\n\n      \nstatus_code\n:\n \n200\n\n\n\n\n\n\nMore examples on \nmultipart/form-data\n tests can be found \nhere\n\n\nResponse Validation\n\n\nJust-API allows you to validate response without writing any code, you can validate following in a response by specifying what to validate.\n\n\n\n\nStatus code\n\n\nHeaders\n\n\nJSON schema\n\n\nJSON body\n\n\n\n\nYou can also have a custom validator function that implements your custom validation logic.\n\n\nStatus code validation\n\n\nProvide \nstatus_code\n attribute in response and Just-API matches Response's Status code against the specification.\nTest will fail when Actual response's status code does not match with specified value.\n\n\nA sample:\n\n\n  \n-\n \nname\n:\n \nget users\n\n    \nrequest\n:\n\n      \npath\n:\n \n/users\n\n      \nmethod\n:\n \nget\n\n    \nresponse\n:\n\n      \nstatus_code\n:\n \n400\n\n\n\n\n\n\nHeaders validation\n\n\nWhen you specify headers in response, Just-API will validate response headers against your specification.\n\n\nA sample on how to write headers validation.\n\n\n  \n-\n \nname\n:\n \nget users\n\n    \nrequest\n:\n\n      \npath\n:\n \n/users\n\n      \nmethod\n:\n \nget\n\n    \nresponse\n:\n\n      \nheaders\n:\n\n        \n-\n \nname\n:\n \ncontent-type\n\n          \nvalue\n:\n \napplication/json\n\n\n\n\n\n\nYou can even match header against a regex instead of exact value, like below:\n\n\nFollowing response specification would check if response header \ncontent-type\n matches with regex pattern \n'json'\n.\n\n\n  \n-\n \nname\n:\n \nget users\n\n    \nrequest\n:\n\n      \npath\n:\n \n/users\n\n      \nmethod\n:\n \nget\n\n    \nresponse\n:\n\n      \nheaders\n:\n\n        \n-\n \nname\n:\n \ncontent-type\n\n          \nvalue\n:\n \n!!js/regexp\n \njson\n\n\n\n\n\n\nMore examples on response header validation can be found \nhere\n\n\nResponse JSON schema validation\n\n\nSometimes you may want to validate the schema of JSON received in response's body, which will allow you to ensure that server is sending data exactly what you are expecting.\n\n\nwith Just-API, you can validate the response JSON schema by specifying the \njson_schema\n attribute in response.\n\n\nFollowing sample shows how to read expected schema from a file and validate response JSON body against it. Here json_schema has two fields, \ntype\n key can be either file or inline.\nWhen \ntype\n is file, you need to provide the relative path to schema file to \n$ref\n key.\n\n\n  \n-\n \nname\n:\n \nget users\n\n    \nrequest\n:\n \n      \npath\n:\n \n/users\n\n      \nmethod\n:\n \nget\n\n    \nresponse\n:\n\n      \njson_schema\n:\n\n          \ntype\n:\n \nfile\n\n          \n$ref\n:\n \nstatic/schema/expected_schema_for_users.json\n \n#path to the expected schema file\n\n\n\n\n\n\nYou can also specify expected JSON schema in YAML by setting type as \ninline\n and assigning a string to \n$ref\n like below:\n\n\n  \n-\n \nname\n:\n \nget users\n\n    \nrequest\n:\n \n      \npath\n:\n \n/users\n\n      \nmethod\n:\n \nget\n\n    \nresponse\n:\n\n      \njson_schema\n:\n\n          \ntype\n:\n \ninline\n\n          \n$ref\n:\n \n\n                \n{\n\n                  \n$id\n: \nhttp://example.com/example.json\n,\n\n                  \ntype\n: \nobject\n,\n\n                  \n$schema\n: \nhttp://json-schema.org/draft-06/schema#\n,\n\n                  \nproperties\n: {\n\n                    \nfirstName\n: {\n\n                      \n$id\n: \n/properties/firstName\n,\n\n                      \ntype\n: \nstring\n\n                    \n}\n\n                  \n}\n\n                \n}\n\n\n\n\n\n\nIf you are not sure about JSON schema standard, Please refer to \nJSON schema\n\n\nMore examples on response JSON schema validation can be found \nhere\n\n\nResponse JSON body validation\n\n\nWhen you want to validate one or many fields of response JSON, you can do so by providing \njson_data\n as part of response specification.\n\n\njson_data\n should have a list of pairs of path \n value, where path tells Just-API how to locate the field, and value is the expected value for that field.\n\n\nFollowing sample shows that.\n\n\n  \n-\n \nname\n:\n \nget users\n\n    \nrequest\n:\n \n      \npath\n:\n \n/users\n\n      \nmethod\n:\n \nget\n\n    \nresponse\n:\n\n      \njson_data\n:\n\n        \n-\n \npath\n:\n \n$.[0].firstName\n\n          \nvalue\n:\n \njohn\n\n\n\n\n\n\nIf you are not sure on how to generate JSON path, Please refer to \nJSON path\n\n\nMore examples on response JSON data validation can be found \nhere\n\n\nUser defined custom response validator functions\n\n\nWhen you need to validate a response using your custom logic, you can do so by providing a \ninline\n or \nmodule\n custom javascript function to \ncustom_validator\n attribute.\n\n\nJust-API will invoke the custom function by passing the response to function's context, so you can access the response using \nthis.response\n.\n\n\nWhen you need more details from response, \nthis.response\n will also have following properties.\n\n\n\n\nbody\n\n\nstatusCode\n\n\nstatusMessage\n\n\nheaders\n\n\nbody\n\n\nduration\n\n\n\n\nHere's a sample on how to specify a custom inline Javascript function to validate the response\n\n\n  \n-\n \nname\n:\n \nget users\n\n    \nrequest\n:\n\n      \npath\n:\n \n/users\n\n      \nmethod\n:\n \nget\n\n    \nresponse\n:\n\n      \nstatus_code\n:\n \n200\n\n      \ncustom_validator\n:\n\n        \nrun_type\n:\n \ninline\n\n        \ninline\n:\n\n          \nfunction\n:\n \n!!js/function\n \n\n            \nfunction() {\n\n              \nvar body = JSON.parse(this.response.body);\n\n\n              \nif (body.users[0].firstName !== \njohn\n)\n\n                  \nthrow new Error(\nfirst user\ns name is not john\n);\n\n            \n}\n\n\n\n\n\n\nYou can also specify a custom function defined \n exported in a module by providing \nrun_type\n as module and module path like below.\n\n\n  \n-\n \nname\n:\n \nget users\n\n    \nrequest\n:\n\n      \npath\n:\n \n/users\n\n      \nmethod\n:\n \nget\n\n    \nresponse\n:\n\n      \nstatus_code\n:\n \n200\n\n      \ncustom_validator\n:\n\n        \nrun_type\n:\n \nmodule\n\n        \nmodule\n:\n\n          \nmodule_path\n:\n \nmodules/custom_module.js\n \n# module path\n\n          \nfunction_name\n:\n \nvalidateUsersResponse\n\n\n\n\n\n\nMore examples on validating response using custom functions can be found \nhere\n\n\nCustom Javascript functions\n\n\nJust-API allows users to specify custom Javascript functions for (hooks and custom validator).\n\n\nThese custom Javascript functions can be inline or defined in a module. They can be synchronous or asynchronous (defined with async keyword). \n\n\nCutom inline and module functions\n\n\ncustom inline function\n\n\nAn \ninline\n synchronous function is defined as below.\n\n\n  \ncustom_validator\n:\n\n    \nrun_type\n:\n \ninline\n\n    \ninline\n:\n\n      \nfunction\n:\n \n!!js/function\n \n\n        \nfunction() {\n\n          \n// some custom code here...\n\n        \n}\n\n\n\n\n\n\nNote that run_type is \ninline\n and function is mapped to function key of \ninline\n attribute. Tagging with \n!!js/function\n is how you tell Just-API parser to consider it as a custom synchronous function.\n\n\ncustom module function\n\n\nA \nmodule\n synchronous function is specified as below.\n\n\n \ncustom_validator\n:\n\n   \nrun_type\n:\n \nmodule\n\n   \nmodule\n:\n\n     \nmodule_path\n:\n \nmodules/custom_module.js\n\n     \nfunction_name\n:\n \ncustomFunctionName\n\n\n\n\n\n\nNote that run_type is \nmodule\n and function details are mapped to \nmodule\n attribute. \nmodule_path\n has the relative path to the JS file from Node's process's current working directory or relative to suite's path if you set \nlocate_files_relative\n to true in \nmeta\n section of the suite.\nThe JS file is expected to be a standard Node.js module.\n\nfunction_name\n is the function exported in the module.\n\n\nAsync support for custom functions with promises\n\n\nJust-API does not support callback mechanism, Wrap async opeartions with promises and return a promise.\n\n\nCustom functions can be asynchronous defined with async keyword, Just-API waits until the promise returned by the async function is resolved or rejected.\n\n\nAn \ninline\n asynchronous function is defined as below.\n\n\n  \ncustom_validator\n:\n\n    \nrun_type\n:\n \ninline\n\n    \ninline\n:\n\n      \nfunction\n:\n \n!js/asyncFunction\n \n\n        \nasync function() {\n\n          \n// some custom asynchrounous code here...\n\n        \n}\n\n\n\n\n\n\nNote that run_type is \ninline\n and function is mapped to function key of \ninline\n attribute. Tagging with \n!js/asyncFunction\n is how you tell Just-API parser to consider it as a custom asynchronous function.\n\n\nA \nmodule\n asynchronous function is specified as below.\n\n\n \ncustom_validator\n:\n\n   \nrun_type\n:\n \nmodule\n\n   \nmodule\n:\n\n     \nmodule_path\n:\n \nmodules/custom_module.js\n\n     \nfunction_name\n:\n \ncustomAsyncFunctionName\n\n\n\n\n\n\nNote that run_type is \nmodule\n and function details are mapped to \nmodule\n attribute. \nmodule_path\n has the relative path to the JS file from Node's process's current working directory or relative to suite's path if you set \nlocate_files_relative\n to true in \nmeta\n section of the suite. The JS file is expected to be a standard Node.js module.\n\nfunction_name\n is the async function defined with async keyword and exported in the module.\n\n\nSuite configuration\n\n\nWhen you are running tests, you would want to configure API host, port etc, according to the environment you are testing.\n\n\nIn order to facilitate this, Just-API provides a \nconfiguration\n section in each suite, where you can have a \ncustom_configuration\n attribute \nand provide a custom JS function to set suite configuration.\n\n\nHere's an example to do that with an inline custom JS function.\n\n\nconfiguration\n:\n\n  \nscheme\n:\n \nhttps\n\n  \ncustom_configuration\n:\n\n    \nrun_type\n:\n \ninline\n\n    \ninline\n:\n\n      \nfunction\n:\n \n!!js/function\n \n\n        \nfunction() {\n\n          \nif (process.env.TEST_ENVIRONMENT === \nDev\n) {\n\n             \nthis.host = \ndev-host.com\n;\n\n          \n}\n\n\n          \nif (process.env.TEST_ENVIRONMENT === \nQA\n) { \n\n            \nthis.host = \nqa-host.com\n;\n\n          \n}\n\n        \n}\n\n\n\n\n\n\nyou can also have a module based custom JS function to configure a suite.\n\n\nNote that \ncustom_configuration\n is optional. you can always specify static suite configuration if test environment details does not change for you.\n\n\nconfiguration\n:\n\n  \nscheme\n:\n \nhttps\n\n  \nhost\n:\n \ntesthost.com\n\n  \nport\n:\n \n8000\n\n  \nbase_path\n:\n \n/api\n\n\n\n\n\n\nSee More examples \nhere\n\n\nHooks\n\n\nJust-API supports following hooks so it's easy to manage tests.\n\n\nSuite specific hooks\n\n\nThese can be specified as part of \nhooks\n attribute.\n\n\n\n\nBefore all  (runs before all specs in a suite)\n\n\nAfter all   (runs after all specs in a suite)\n\n\nBefore each  (runs before each spec in a suite )\n\n\nAfter each  (runs after each passed spec in a suite )\n\n\n\n\nTest specific hooks\n\n\nThese can be specified for each test as required.\n\n\n\n\nBefore test  (runs before the spec, you can use this hook to setup test pre-requisites )\n\n\nAfter test  (runs after the spec if spec passes, you can use this hook to teardown/clear any test specific data  )\n\n\n\n\nCheck out some samples of hooks \nhere\n\n\nDynamic request construction\n\n\nStatic specification of a request is not possible all the time. Sometimes a test depends on data returned by another request, where you would want to run the dependency spec first and fetch required data from it and pass it on to current test request. To handle usecases like this, Just-API provides a \nbefore_test\n hook for every test. Using this hook you can run test pre-requisites and update request data for actual test.\n\n\nTypically we need to build dynamic requests when a request depends on the data received from another request. In such cases, you \ncan run the dependency spec in before_test hook and use the response to build the actual request for test.\n\n\nHeaders\n\n\nUpdating or overriding request headers in \nbefore test\n hook:\n\n\n  \n-\n \nname\n:\n \nsend headers specified in before test hook\n\n    \nbefore_test\n:\n\n      \nrun_type\n:\n \ninline\n\n      \ninline\n:\n\n        \nfunction\n:\n \n!!js/function\n \n\n          \nfunction() {\n\n            \nthis.test.headers = { Authorization: \nsome token\n };\n\n          \n}\n\n    \nrequest\n:\n\n      \npath\n:\n \n/users\n\n      \nmethod\n:\n \nget\n\n    \nresponse\n:\n\n      \nstatus_code\n:\n \n200\n\n\n\n\n\n\nQuery params\n\n\nUpdating or overriding request query params in \nbefore test\n hook:\n\n\n  \n-\n \nname\n:\n \nQuery params added in hook\n\n    \nbefore_test\n:\n\n      \nrun_type\n:\n \ninline\n\n      \ninline\n:\n\n        \nfunction\n:\n \n!!js/function\n \n\n          \nfunction() {\n\n            \nthis.test.query_params = { limit: 10 };\n\n          \n}\n\n    \nrequest\n:\n\n       \npath\n:\n \n/users\n\n       \nmethod\n:\n \nget\n\n    \nresponse\n:\n\n       \nstatus_code\n:\n \n200\n\n\n\n\n\n\nPath params\n\n\nUpdating or overriding request Path params in \nbefore test\n hook:\n\n\n  \n-\n \nname\n:\n \npath params added in hook\n\n    \nbefore_test\n:\n\n      \nrun_type\n:\n \ninline\n\n      \ninline\n:\n\n        \nfunction\n:\n \n!!js/function\n \n\n          \nfunction() {\n\n            \nthis.test.path_params = { id: 1 };\n\n          \n}\n\n    \nrequest\n:\n\n       \npath\n:\n \n/user/{id}\n\n       \nmethod\n:\n \nget\n\n    \nresponse\n:\n\n       \nstatus_code\n:\n \n200\n\n\n\n\n\n\nBody\n\n\nYou can also define request payload at runtime using hook like below:\n\n\n  \n-\n \nname\n:\n \nPayload defined in hook\n\n    \nbefore_test\n:\n\n      \nrun_type\n:\n \ninline\n\n      \ninline\n:\n\n        \nfunction\n:\n \n!!js/function\n \n\n          \nfunction() {\n\n            \nthis.test.payload = { body: {type: \njson\n, content: { firstName: \njohn\n,\n\n             \nlastName: \ndoe\n}} };\n\n          \n}\n\n    \nrequest\n:\n\n       \npath\n:\n \n/users\n\n       \nmethod\n:\n \npost\n\n       \nheaders\n:\n\n         \n-\n \nname\n:\n \ncontent-type\n\n           \nvalue\n:\n \napplication/json\n\n    \nresponse\n:\n\n       \nstatus_code\n:\n \n201\n\n\n\n\n\n\nCustom context\n\n\nYou will have access to suite context and test context in hooks, So you can use them as a way to store custom data to use in later hooks.\n\n\nSuite context can be accessed in hooks using \nthis.suite\n.\nTest context can be accessed in test specific hooks using 'this.test'.\n\n\nStoring suite \n test data in context for reuse\n\n\nWhen you have some data that you want to use later in some tests, you can store the data in suite context in \nbefore_all\n hook.\n\n\n  \nbefore_all\n:\n\n    \nrun_type\n:\n \ninline\n\n    \ninline\n:\n\n      \nfunction\n:\n \n!!js/function\n \n\n        \nfunction() {\n\n           \nthis.suite.serviceSecret = \nsecret\n;\n\n        \n}\n\n\n\n\n\n\nand later when you need the secret in a test, you can access it in before_test hook.\n\n\n  \n-\n \nname\n:\n \nusing suite context in before test hook\n\n    \nbefore_test\n:\n\n      \nrun_type\n:\n \ninline\n\n      \ninline\n:\n\n        \nfunction\n:\n \n!!js/function\n \n\n          \nfunction() {\n\n              \nthis.test.headers = { Authorization: this.suite.serviceSecret };\n\n          \n}\n\n    \nrequest\n:\n\n      \npath\n:\n \n/users\n\n      \nmethod\n:\n \nget\n\n    \nresponse\n:\n \n      \nstatus_code\n:\n \n200\n\n\n\n\n\n\nSimilarly you can set test context in before_test hook using \nthis.test\n and access it using `this.test' in after_test hook.\n\n\nSpec dependencies\n\n\nJust-API allows testing APIs in a flow, where one request depends on response data from another request. This is really useful when you are testing complex transaction APIs.\n\n\nRunning dependencies\n\n\nRunning pre-requisite requests can be done using hooks. There is \nbefore_each\n and \nbefore_test\n hooks.\n\n\nIf you have a dependency specific to a test, then you might want to use \nbefore_test\n hook to run the dependecy spec.\n\n\nThere is support for 2 types of dependencies, \nIntrasuite\n \n \nIntersuite\n spec.\n\n\nIntrasuite spec dependencies\n\n\nIntrasuite dependency is when you have a dependency that is specified in the same suite. You can then run the dependency by\nusing \nthis.runSpec()\n in a hook. runSpec function takes 2 arguments. First argument is the name of your dependency spec and second argument is an object with additional information you want to pass to the request such as headers, query params, path params, and body.\n\n\nFollowing set of specs show how to run dependencies as part of a test and use the data for subsequent requests.\n\n\nspecs\n:\n\n  \n-\n \nname\n:\n \nthis is the dependency spec\n\n    \nenabled\n:\n \nfalse\n\n    \nrequest\n:\n\n      \npath\n:\n \n/token\n\n      \nmethod\n:\n \nget\n\n    \nresponse\n:\n\n      \nstatus_code\n:\n \n200\n\n\n  \n-\n \nname\n:\n \nactual test spec\n\n    \nbefore_test\n:\n\n      \nrun_type\n:\n \ninline\n\n      \ninline\n:\n\n        \nfunction\n:\n \n!js/asyncFunction\n \n\n          \nasync function() {\n\n            \nvar response = await this.runSpec(\nthis is the dependency spec\n);\n\n            \nvar tokenResponse = JSON.parse(response.body);\n\n            \nthis.test.headers = { Authorization:  tokenResponse.token };\n\n          \n}\n\n    \nrequest\n:\n\n      \npath\n:\n \n/users\n\n      \nmethod\n:\n \nget\n\n    \nresponse\n:\n\n      \nstatus_code\n:\n \n200\n\n\n\n\n\n\nIntersuite spec dependencies\n\n\nIntersuite dependency is when you have a dependency that is specified in another suite but you import it using \nspec_dependencies\n construct.\n\n\nRunning Intersuite dependency is similar to running Intrasuite dependency.\n\n\nYou can import specs defined in another suite by providing the path of the suite to \nspec_dependencies\n.\n\n\nspec_dependencies\n:\n\n  \n-\n \nsuites/anothersuite.yml\n \n\n\n\n\n\nPath is relative to current working directory of Node process or relative to suite's path if you set \nlocate_files_relative\n to true in \nmeta\n section of the suite.\n\n\nYou can import specs from one or more suites by listing their paths.\n\n\nNote that these imported specs will only be available when you run them using \nthis.runSpec\n.\n\n\nPlease find some examples on dependencies \nhere\n\n\nSkipping\n\n\nYou can explicitly skip suites and tests with specification.\n\n\nSkipping a suite\n\n\nWhen you have a suite in a directory, but want to skip running it for some reason, you can do so by providing\n  \nfalse\n as value for enabled key of \nmeta\n section in a suite, Just-API will skip the suite.\n\n\n \nmeta\n:\n\n  \nname\n:\n \nDisabled suite\n\n  \nenabled\n:\n \nfalse\n\n\nconfiguration\n:\n\n  \nscheme\n:\n \nhttp\n\n  \nhost\n:\n \n127.0.0.1\n\n\nspecs\n:\n\n  \n-\n \nname\n:\n \nget users\n\n    \nrequest\n:\n\n      \npath\n:\n \n/users\n\n      \nmethod\n:\n \nget\n\n    \nresponse\n:\n\n      \nstatus_code\n:\n \n200\n\n\n\n\n\n\nNote that if any error occurs before Just-API reads \nmeta\n info of the suite, then suite will be marked as failure.\n\n\nSkipping a test\n\n\nWhen you have a set of specs in a suite, but want to skip a spec, you can do so by providing \nfalse\n as value for enabled key of the spec.\n\n\n  \n-\n \nname\n:\n \ndisabled spec\n\n    \nenabled\n:\n \nfalse\n\n    \nrequest\n:\n\n      \npath\n:\n \n/\n\n      \nmethod\n:\n \nget\n\n    \nresponse\n:\n\n      \nstatus_code\n:\n \n200\n\n\n\n\n\n\nJust-API will mark the spec as a skipped test.\n\n\nreusing test specification\n\n\nApart from readability, an awesome thing about YAML is that you can reuse parts of the specification.\n\n\nRefer to \ndry\n to see how you can reuse stuff in YAML.\n\n\nyou can see how response specification is being reused below with \n and \n*\n\n\nmeta\n:\n\n  \nname\n:\n \nsuite name\n\n\nconfiguration\n:\n\n  \nscheme\n:\n \nhttp\n\n  \nhost\n:\n \nexample.com\n\n\nspecs\n:\n\n  \n-\n \nname\n:\n \nget user1\n\n    \nrequest\n:\n\n      \npath\n:\n \n/users/1\n\n      \nmethod\n:\n \nget\n\n    \nresponse\n:\n \ndefault_response\n\n      \nstatus_code\n:\n \n200\n\n\n  \n-\n \nname\n:\n \nget user2\n\n    \nrequest\n:\n \ndefault_request\n\n      \npath\n:\n \n/users/1\n\n      \nmethod\n:\n \nget\n\n    \nresponse\n:\n \n*default_response\n\n\n\n\n\n\nRetrying failed tests\n\n\nSometimes a resource takes a bit of time to get to a state you expect, for instance when you are polling a job status and it goes \nto completed state after a while. In such cases, you would want to retry hitting the same request few times. \n\n\nIf you see below sample, response specification says expect 200 status code. If the response validation fails then Just-API attempts to retry the request if you have specified a \nretry\n attribute.\nHere the request will be attempted 3 times denoted by \ncount\n with 10ms wait before each attempt.\n\n\nwait_before_each\n is an optional attribute to specify how many milliseconds you want to wait before each attempt.\n\n\n  \n-\n \nname\n:\n \nretry example\n\n    \nrequest\n:\n\n      \npath\n:\n \n/retryPath\n\n      \nmethod\n:\n \nget\n\n    \nretry\n:\n\n      \ncount\n:\n \n3\n\n      \nwait_before_each\n:\n \n10\n\n    \nresponse\n:\n\n      \nstatus_code\n:\n \n200\n\n\n\n\n\n\nLooping\n\n\nYou can use the loop construct to loop through a list of items, each item generating a test.\n\n\nThe list of items can be specified in spec beforehand or you can specify a custom JS function which returns a list of items.\n\n\nHere's how a static loop is specified, \ntype\n is static and loop list is mapped to \nstatic\n field as list of items.\nYou will have access to that item in before_test hook by accessing \nthis.loopItem\n.\n\n\n  \n-\n \nname\n:\n \nstatic loop test\n\n    \nloop\n:\n\n      \ntype\n:\n \nstatic\n\n      \nstatic\n:\n\n        \n-\n \n2\n\n        \n-\n \n3\n\n    \nbefore_test\n:\n\n      \nrun_type\n:\n \ninline\n\n      \ninline\n:\n\n        \nfunction\n:\n \n!!js/function\n \n\n          \nfunction() {\n\n            \nthis.test.query_params = { limit : this.loopItem };\n\n          \n}\n\n    \nrequest\n:\n\n      \npath\n:\n \n/users\n\n      \nmethod\n:\n \nget\n\n    \nresponse\n:\n\n      \nstatus_code\n:\n \n200\n\n\n\n\n\n\nThere's another way to provide a list of items, with \ndynamic\n type and a custom JS function.\n\n\n  \n-\n \nname\n:\n \ndynamic loop test\n\n    \nloop\n:\n\n      \ntype\n:\n \ndynamic\n\n      \ndynamic\n:\n\n        \nrun_type\n:\n \ninline\n\n        \ninline\n:\n\n          \nfunction\n:\n \n!!js/function\n  \n\n            \nfunction() {\n\n              \nreturn [2, 3];\n\n            \n}           \n\n    \nbefore_test\n:\n\n      \nrun_type\n:\n \ninline\n\n      \ninline\n:\n\n        \nfunction\n:\n \n!!js/function\n \n\n          \nfunction() {\n\n            \nthis.test.query_params = { limit : this.loopItem };\n\n          \n}           \n\n    \nrequest\n:\n\n      \npath\n:\n \n/users\n\n      \nmethod\n:\n \nget\n\n    \nresponse\n:\n\n      \nstatus_code\n:\n \n200\n\n\n\n\n\n\nNote that if your loop has a list of n items, n tests will be generated at runtime.\n\n\nAdditional features\n\n\nFollowing are some additional features offered by Just-API.\n\n\nreports test duration\n\n\nJust-API reports duration of each test run in all formats of reports.\n\n\nrunning only tests matching with a given pattern/text\n\n\nIf you want to run only specs matches with a given text or pattern, you can do so by using \n--grep\n option.\n\n\nFollowing invocation will run all specs whose name matches with 'user' string.\n\n\n./node_modules/.bin/just-api --grep user specs\n\n\n\n\n\nAdditional request options\n\n\nFollowing additional request options are supported.\n\n\n\n\nfollowRedirect - follow HTTP 3xx responses as redirects.\n\n\nfollowAllRedirects - follow non-GET HTTP 3xx responses as redirects.\n\n\nfollowOriginalHttpMethod - by default we redirect to HTTP method GET. you can enable this property to redirect to the original HTTP method (default: false)\n\n\nencoding - encoding to be used on setEncoding of response data. If null, the body is returned as a Buffer. \n   Anything else (including the default value of undefined) will be passed as the encoding parameter to toString() (meaning this is effectively utf8 by default). (Note: if you expect binary data, you should set encoding: null.)\n\n\ngzip - if true, adds an Accept-Encoding header to request compressed content encodings from the server (if not already present) and decodes supported content encodings in the response.\n\n\n\n\nA sample spec on how to specify these options:\n\n\n  \n-\n \nname\n:\n \nspec with redirection disabled\n\n    \nrequest\n:\n \n      \npath\n:\n \n/home\n\n      \nmethod\n:\n \nget\n\n      \nadditional_options\n:\n\n        \nfollowRedirect\n:\n \nfalse\n\n        \ngzip\n:\n \ntrue\n\n    \nresponse\n:\n\n      \nstatus_code\n:\n \n200\n\n\n\n\n\n\nFinding suites recursively\n\n\nWhen you want to run suites stored in a directory hierarchy spanning more than one nested level, you can invoke the Just-API with \n--recursive\n option.\n\n\n./node_modules/.bin/just-api --recursive specs\n\n\n\n\n\nProper error reporting\n\n\nWhen a test or suite fails, Just-API provides the correct error, that caused the failure in reports.\n\n\nExit code for CI support\n\n\nJust-API exits with proper exit code, so you can use it in CI to determine the status of your tests.\n\n\nUsually exit code is equal to number of failed suites unless some unexpected error occurs.\n\n\nLogging HTTP request/response data for failed tests\n\n\nWhen a test with multiple dependencies fails it's hard to track which request has failed. To make failure tracking easy, Just-API allows you to ask for HTTP call details for failed tests. You would be able to see all HTTP calls made for a failed test in HTML or JSON report.\n\n\nTo enable this feature you need to invoke Just-API with \n--reporter-options logRequests\n\n\n./node_modules/.bin/just-api --reporter html --reporter-options logRequests specs\n\n\n\n\n\nNo callbacks\n\n\nYou might have observed that there is no mention of callbacks anywhere. yes, Just-API does not support callback mechanism when running custom JS functions.\nThis is to encourage usage of promises for asynchronous operations.\n\n\nWhen you are dealing with asynchronous tasks, wrap them in a async function and return a promise.\n\n\nRunning suites in parallel\n\n\nSee \npage\n \n\n\nReporters\n\n\nSee \npage", 
            "title": "Features"
        }, 
        {
            "location": "/features/#just-api-features", 
            "text": "", 
            "title": "Just-API Features"
        }, 
        {
            "location": "/features/#request-specification", 
            "text": "A typical request specification includes request method, path, headers, query params, path params, and payload (if applicable).", 
            "title": "Request Specification"
        }, 
        {
            "location": "/features/#request-methods", 
            "text": "Just-API supports following HTTP request methods. You can have a request specification with\nany of these HTTP methods.   GET  POST  PUT  PATCH  DELETE  HEAD  OPTIONS", 
            "title": "Request Methods"
        }, 
        {
            "location": "/features/#specifying-headers-query-params-path-params", 
            "text": "Specify Request headers to  headers  key as a list of name, value pairs. \nSpecify Request Query params to  query_params  key as a list of name, value pairs. \nSpecify Request Path params to  path_params  key as a list of name, value pairs.  A sample test specification with method, headers, query params and path params:     -   name :   A sample test \n     request : \n        path :   /user/{userId}/posts/{postId} \n        method :   get \n        headers : \n          -   name :   Accept \n            value :   application/json \n        path_params : \n           -   name :   userId \n             value :   12876 \n           -   name :   postId \n             value :   2 \n        query_params : \n           -   name :   limit \n             value :   10 \n     response : \n        status_code :   200", 
            "title": "Specifying Headers, Query params, Path params"
        }, 
        {
            "location": "/features/#request-body-specification", 
            "text": "When you need to send request body for POST, PUT and PATCH requests, you can specify the body to  payload  key.  You will need to specify  content-type  header and body  type  as shown below\nHere's how to send JSON body with a POST request     -   name :   create a new user \n     request :  \n       path :   /users \n       method :   post \n       headers : \n         -   name :   content-type \n           value :   application/json \n       payload : \n           body : \n             type :   json \n             content : \n               firstName :   john \n               lastName :   doe \n     response : \n       status_code :   201   You can also send binary data as body from a file as shown below.     -   name :   post binary data (file) as body \n     request : \n       path :   /uploadImage \n       method :   post \n       headers : \n         -   name :   content-type \n           value :   image/png \n       payload : \n           body : \n             type :   binary  \n             content :   static/assets/image.png   # Image path \n     response : \n       status_code :   200   Note that the image path should be relative to Node process's current working directory or relative to suite's path if you set  locate_files_relative  to true in  meta  section of the suite.  Checkout more examples on how to specify request body  here", 
            "title": "Request Body Specification"
        }, 
        {
            "location": "/features/#x-www-form-urlencoded-multipart-requests-file-uploads", 
            "text": "Just-API supports  x-www-form-urlencoded  and  multipart/form-data  requests, using which you can upload files and perform tests on complex requests.", 
            "title": "x-www-form-urlencoded, Multipart requests, file uploads"
        }, 
        {
            "location": "/features/#specify-x-www-form-urlencoded-request", 
            "text": "To create a  x-www-form-urlencoded  request test, you will need to specify the  content-type  header and form body like below:  Note that  payload  should have a key  form  and it should contain form data in key value pairs.     -   name :   Authenticate a user \n     request : \n       path :   /authenticate \n       method :   post \n       headers : \n         -   name :   content-type \n           value :   application/x-www-form-urlencoded \n       payload : \n           form : \n             userName :   john.doe \n             password :   john.doe.password \n     response : \n       status_code :   200   More examples on  x-www-form-urlencoded  tests can be found  here", 
            "title": "specify x-www-form-urlencoded request"
        }, 
        {
            "location": "/features/#specify-multipartform-data-request", 
            "text": "Here's how you can specify a multipart request.  Note that  payload  should have a key  form_data  and it should contain list of form data fields.     -   name :   post multipart form data - single file and field \n     request : \n       path :   /imageNText \n       method :   post \n       headers : \n         -   name :   content-type \n           value :   multipart/form-data \n       payload : \n           form_data : \n             -   name :   image_name \n               content :   static/assets/logo.png   # file path \n               type :   file \n             -   name :   field1 \n               content :   value1 \n               type :   text \n     response : \n       status_code :   200   More examples on  multipart/form-data  tests can be found  here", 
            "title": "specify multipart/form-data request"
        }, 
        {
            "location": "/features/#response-validation", 
            "text": "Just-API allows you to validate response without writing any code, you can validate following in a response by specifying what to validate.   Status code  Headers  JSON schema  JSON body   You can also have a custom validator function that implements your custom validation logic.", 
            "title": "Response Validation"
        }, 
        {
            "location": "/features/#status-code-validation", 
            "text": "Provide  status_code  attribute in response and Just-API matches Response's Status code against the specification.\nTest will fail when Actual response's status code does not match with specified value.  A sample:     -   name :   get users \n     request : \n       path :   /users \n       method :   get \n     response : \n       status_code :   400", 
            "title": "Status code validation"
        }, 
        {
            "location": "/features/#headers-validation", 
            "text": "When you specify headers in response, Just-API will validate response headers against your specification.  A sample on how to write headers validation.     -   name :   get users \n     request : \n       path :   /users \n       method :   get \n     response : \n       headers : \n         -   name :   content-type \n           value :   application/json   You can even match header against a regex instead of exact value, like below:  Following response specification would check if response header  content-type  matches with regex pattern  'json' .     -   name :   get users \n     request : \n       path :   /users \n       method :   get \n     response : \n       headers : \n         -   name :   content-type \n           value :   !!js/regexp   json   More examples on response header validation can be found  here", 
            "title": "Headers validation"
        }, 
        {
            "location": "/features/#response-json-schema-validation", 
            "text": "Sometimes you may want to validate the schema of JSON received in response's body, which will allow you to ensure that server is sending data exactly what you are expecting.  with Just-API, you can validate the response JSON schema by specifying the  json_schema  attribute in response.  Following sample shows how to read expected schema from a file and validate response JSON body against it. Here json_schema has two fields,  type  key can be either file or inline.\nWhen  type  is file, you need to provide the relative path to schema file to  $ref  key.     -   name :   get users \n     request :  \n       path :   /users \n       method :   get \n     response : \n       json_schema : \n           type :   file \n           $ref :   static/schema/expected_schema_for_users.json   #path to the expected schema file   You can also specify expected JSON schema in YAML by setting type as  inline  and assigning a string to  $ref  like below:     -   name :   get users \n     request :  \n       path :   /users \n       method :   get \n     response : \n       json_schema : \n           type :   inline \n           $ref :   \n                 { \n                   $id :  http://example.com/example.json , \n                   type :  object , \n                   $schema :  http://json-schema.org/draft-06/schema# , \n                   properties : { \n                     firstName : { \n                       $id :  /properties/firstName , \n                       type :  string \n                     } \n                   } \n                 }   If you are not sure about JSON schema standard, Please refer to  JSON schema  More examples on response JSON schema validation can be found  here", 
            "title": "Response JSON schema validation"
        }, 
        {
            "location": "/features/#response-json-body-validation", 
            "text": "When you want to validate one or many fields of response JSON, you can do so by providing  json_data  as part of response specification.  json_data  should have a list of pairs of path   value, where path tells Just-API how to locate the field, and value is the expected value for that field.  Following sample shows that.     -   name :   get users \n     request :  \n       path :   /users \n       method :   get \n     response : \n       json_data : \n         -   path :   $.[0].firstName \n           value :   john   If you are not sure on how to generate JSON path, Please refer to  JSON path  More examples on response JSON data validation can be found  here", 
            "title": "Response JSON body validation"
        }, 
        {
            "location": "/features/#user-defined-custom-response-validator-functions", 
            "text": "When you need to validate a response using your custom logic, you can do so by providing a  inline  or  module  custom javascript function to  custom_validator  attribute.  Just-API will invoke the custom function by passing the response to function's context, so you can access the response using  this.response .  When you need more details from response,  this.response  will also have following properties.   body  statusCode  statusMessage  headers  body  duration   Here's a sample on how to specify a custom inline Javascript function to validate the response     -   name :   get users \n     request : \n       path :   /users \n       method :   get \n     response : \n       status_code :   200 \n       custom_validator : \n         run_type :   inline \n         inline : \n           function :   !!js/function   \n             function() { \n               var body = JSON.parse(this.response.body); \n\n               if (body.users[0].firstName !==  john ) \n                   throw new Error( first user s name is not john ); \n             }   You can also specify a custom function defined   exported in a module by providing  run_type  as module and module path like below.     -   name :   get users \n     request : \n       path :   /users \n       method :   get \n     response : \n       status_code :   200 \n       custom_validator : \n         run_type :   module \n         module : \n           module_path :   modules/custom_module.js   # module path \n           function_name :   validateUsersResponse   More examples on validating response using custom functions can be found  here", 
            "title": "User defined custom response validator functions"
        }, 
        {
            "location": "/features/#custom-javascript-functions", 
            "text": "Just-API allows users to specify custom Javascript functions for (hooks and custom validator).  These custom Javascript functions can be inline or defined in a module. They can be synchronous or asynchronous (defined with async keyword).", 
            "title": "Custom Javascript functions"
        }, 
        {
            "location": "/features/#cutom-inline-and-module-functions", 
            "text": "", 
            "title": "Cutom inline and module functions"
        }, 
        {
            "location": "/features/#custom-inline-function", 
            "text": "An  inline  synchronous function is defined as below.     custom_validator : \n     run_type :   inline \n     inline : \n       function :   !!js/function   \n         function() { \n           // some custom code here... \n         }   Note that run_type is  inline  and function is mapped to function key of  inline  attribute. Tagging with  !!js/function  is how you tell Just-API parser to consider it as a custom synchronous function.", 
            "title": "custom inline function"
        }, 
        {
            "location": "/features/#custom-module-function", 
            "text": "A  module  synchronous function is specified as below.    custom_validator : \n    run_type :   module \n    module : \n      module_path :   modules/custom_module.js \n      function_name :   customFunctionName   Note that run_type is  module  and function details are mapped to  module  attribute.  module_path  has the relative path to the JS file from Node's process's current working directory or relative to suite's path if you set  locate_files_relative  to true in  meta  section of the suite.\nThe JS file is expected to be a standard Node.js module. function_name  is the function exported in the module.", 
            "title": "custom module function"
        }, 
        {
            "location": "/features/#async-support-for-custom-functions-with-promises", 
            "text": "Just-API does not support callback mechanism, Wrap async opeartions with promises and return a promise.  Custom functions can be asynchronous defined with async keyword, Just-API waits until the promise returned by the async function is resolved or rejected.  An  inline  asynchronous function is defined as below.     custom_validator : \n     run_type :   inline \n     inline : \n       function :   !js/asyncFunction   \n         async function() { \n           // some custom asynchrounous code here... \n         }   Note that run_type is  inline  and function is mapped to function key of  inline  attribute. Tagging with  !js/asyncFunction  is how you tell Just-API parser to consider it as a custom asynchronous function.  A  module  asynchronous function is specified as below.    custom_validator : \n    run_type :   module \n    module : \n      module_path :   modules/custom_module.js \n      function_name :   customAsyncFunctionName   Note that run_type is  module  and function details are mapped to  module  attribute.  module_path  has the relative path to the JS file from Node's process's current working directory or relative to suite's path if you set  locate_files_relative  to true in  meta  section of the suite. The JS file is expected to be a standard Node.js module. function_name  is the async function defined with async keyword and exported in the module.", 
            "title": "Async support for custom functions with promises"
        }, 
        {
            "location": "/features/#suite-configuration", 
            "text": "When you are running tests, you would want to configure API host, port etc, according to the environment you are testing.  In order to facilitate this, Just-API provides a  configuration  section in each suite, where you can have a  custom_configuration  attribute \nand provide a custom JS function to set suite configuration.  Here's an example to do that with an inline custom JS function.  configuration : \n   scheme :   https \n   custom_configuration : \n     run_type :   inline \n     inline : \n       function :   !!js/function   \n         function() { \n           if (process.env.TEST_ENVIRONMENT ===  Dev ) { \n              this.host =  dev-host.com ; \n           } \n\n           if (process.env.TEST_ENVIRONMENT ===  QA ) {  \n             this.host =  qa-host.com ; \n           } \n         }   you can also have a module based custom JS function to configure a suite.  Note that  custom_configuration  is optional. you can always specify static suite configuration if test environment details does not change for you.  configuration : \n   scheme :   https \n   host :   testhost.com \n   port :   8000 \n   base_path :   /api   See More examples  here", 
            "title": "Suite configuration"
        }, 
        {
            "location": "/features/#hooks", 
            "text": "Just-API supports following hooks so it's easy to manage tests.  Suite specific hooks  These can be specified as part of  hooks  attribute.   Before all  (runs before all specs in a suite)  After all   (runs after all specs in a suite)  Before each  (runs before each spec in a suite )  After each  (runs after each passed spec in a suite )   Test specific hooks  These can be specified for each test as required.   Before test  (runs before the spec, you can use this hook to setup test pre-requisites )  After test  (runs after the spec if spec passes, you can use this hook to teardown/clear any test specific data  )   Check out some samples of hooks  here", 
            "title": "Hooks"
        }, 
        {
            "location": "/features/#dynamic-request-construction", 
            "text": "Static specification of a request is not possible all the time. Sometimes a test depends on data returned by another request, where you would want to run the dependency spec first and fetch required data from it and pass it on to current test request. To handle usecases like this, Just-API provides a  before_test  hook for every test. Using this hook you can run test pre-requisites and update request data for actual test.  Typically we need to build dynamic requests when a request depends on the data received from another request. In such cases, you \ncan run the dependency spec in before_test hook and use the response to build the actual request for test.", 
            "title": "Dynamic request construction"
        }, 
        {
            "location": "/features/#headers", 
            "text": "Updating or overriding request headers in  before test  hook:     -   name :   send headers specified in before test hook \n     before_test : \n       run_type :   inline \n       inline : \n         function :   !!js/function   \n           function() { \n             this.test.headers = { Authorization:  some token  }; \n           } \n     request : \n       path :   /users \n       method :   get \n     response : \n       status_code :   200", 
            "title": "Headers"
        }, 
        {
            "location": "/features/#query-params", 
            "text": "Updating or overriding request query params in  before test  hook:     -   name :   Query params added in hook \n     before_test : \n       run_type :   inline \n       inline : \n         function :   !!js/function   \n           function() { \n             this.test.query_params = { limit: 10 }; \n           } \n     request : \n        path :   /users \n        method :   get \n     response : \n        status_code :   200", 
            "title": "Query params"
        }, 
        {
            "location": "/features/#path-params", 
            "text": "Updating or overriding request Path params in  before test  hook:     -   name :   path params added in hook \n     before_test : \n       run_type :   inline \n       inline : \n         function :   !!js/function   \n           function() { \n             this.test.path_params = { id: 1 }; \n           } \n     request : \n        path :   /user/{id} \n        method :   get \n     response : \n        status_code :   200", 
            "title": "Path params"
        }, 
        {
            "location": "/features/#body", 
            "text": "You can also define request payload at runtime using hook like below:     -   name :   Payload defined in hook \n     before_test : \n       run_type :   inline \n       inline : \n         function :   !!js/function   \n           function() { \n             this.test.payload = { body: {type:  json , content: { firstName:  john , \n              lastName:  doe }} }; \n           } \n     request : \n        path :   /users \n        method :   post \n        headers : \n          -   name :   content-type \n            value :   application/json \n     response : \n        status_code :   201", 
            "title": "Body"
        }, 
        {
            "location": "/features/#custom-context", 
            "text": "You will have access to suite context and test context in hooks, So you can use them as a way to store custom data to use in later hooks.  Suite context can be accessed in hooks using  this.suite .\nTest context can be accessed in test specific hooks using 'this.test'.", 
            "title": "Custom context"
        }, 
        {
            "location": "/features/#storing-suite-test-data-in-context-for-reuse", 
            "text": "When you have some data that you want to use later in some tests, you can store the data in suite context in  before_all  hook.     before_all : \n     run_type :   inline \n     inline : \n       function :   !!js/function   \n         function() { \n            this.suite.serviceSecret =  secret ; \n         }   and later when you need the secret in a test, you can access it in before_test hook.     -   name :   using suite context in before test hook \n     before_test : \n       run_type :   inline \n       inline : \n         function :   !!js/function   \n           function() { \n               this.test.headers = { Authorization: this.suite.serviceSecret }; \n           } \n     request : \n       path :   /users \n       method :   get \n     response :  \n       status_code :   200   Similarly you can set test context in before_test hook using  this.test  and access it using `this.test' in after_test hook.", 
            "title": "Storing suite &amp; test data in context for reuse"
        }, 
        {
            "location": "/features/#spec-dependencies", 
            "text": "Just-API allows testing APIs in a flow, where one request depends on response data from another request. This is really useful when you are testing complex transaction APIs.", 
            "title": "Spec dependencies"
        }, 
        {
            "location": "/features/#running-dependencies", 
            "text": "Running pre-requisite requests can be done using hooks. There is  before_each  and  before_test  hooks.  If you have a dependency specific to a test, then you might want to use  before_test  hook to run the dependecy spec.  There is support for 2 types of dependencies,  Intrasuite     Intersuite  spec.", 
            "title": "Running dependencies"
        }, 
        {
            "location": "/features/#intrasuite-spec-dependencies", 
            "text": "Intrasuite dependency is when you have a dependency that is specified in the same suite. You can then run the dependency by\nusing  this.runSpec()  in a hook. runSpec function takes 2 arguments. First argument is the name of your dependency spec and second argument is an object with additional information you want to pass to the request such as headers, query params, path params, and body.  Following set of specs show how to run dependencies as part of a test and use the data for subsequent requests.  specs : \n   -   name :   this is the dependency spec \n     enabled :   false \n     request : \n       path :   /token \n       method :   get \n     response : \n       status_code :   200 \n\n   -   name :   actual test spec \n     before_test : \n       run_type :   inline \n       inline : \n         function :   !js/asyncFunction   \n           async function() { \n             var response = await this.runSpec( this is the dependency spec ); \n             var tokenResponse = JSON.parse(response.body); \n             this.test.headers = { Authorization:  tokenResponse.token }; \n           } \n     request : \n       path :   /users \n       method :   get \n     response : \n       status_code :   200", 
            "title": "Intrasuite spec dependencies"
        }, 
        {
            "location": "/features/#intersuite-spec-dependencies", 
            "text": "Intersuite dependency is when you have a dependency that is specified in another suite but you import it using  spec_dependencies  construct.  Running Intersuite dependency is similar to running Intrasuite dependency.  You can import specs defined in another suite by providing the path of the suite to  spec_dependencies .  spec_dependencies : \n   -   suites/anothersuite.yml    Path is relative to current working directory of Node process or relative to suite's path if you set  locate_files_relative  to true in  meta  section of the suite.  You can import specs from one or more suites by listing their paths.  Note that these imported specs will only be available when you run them using  this.runSpec .  Please find some examples on dependencies  here", 
            "title": "Intersuite spec dependencies"
        }, 
        {
            "location": "/features/#skipping", 
            "text": "You can explicitly skip suites and tests with specification.", 
            "title": "Skipping"
        }, 
        {
            "location": "/features/#skipping-a-suite", 
            "text": "When you have a suite in a directory, but want to skip running it for some reason, you can do so by providing\n   false  as value for enabled key of  meta  section in a suite, Just-API will skip the suite.    meta : \n   name :   Disabled suite \n   enabled :   false  configuration : \n   scheme :   http \n   host :   127.0.0.1  specs : \n   -   name :   get users \n     request : \n       path :   /users \n       method :   get \n     response : \n       status_code :   200   Note that if any error occurs before Just-API reads  meta  info of the suite, then suite will be marked as failure.", 
            "title": "Skipping a suite"
        }, 
        {
            "location": "/features/#skipping-a-test", 
            "text": "When you have a set of specs in a suite, but want to skip a spec, you can do so by providing  false  as value for enabled key of the spec.     -   name :   disabled spec \n     enabled :   false \n     request : \n       path :   / \n       method :   get \n     response : \n       status_code :   200   Just-API will mark the spec as a skipped test.", 
            "title": "Skipping a test"
        }, 
        {
            "location": "/features/#reusing-test-specification", 
            "text": "Apart from readability, an awesome thing about YAML is that you can reuse parts of the specification.  Refer to  dry  to see how you can reuse stuff in YAML.  you can see how response specification is being reused below with   and  *  meta : \n   name :   suite name  configuration : \n   scheme :   http \n   host :   example.com  specs : \n   -   name :   get user1 \n     request : \n       path :   /users/1 \n       method :   get \n     response :   default_response \n       status_code :   200 \n\n   -   name :   get user2 \n     request :   default_request \n       path :   /users/1 \n       method :   get \n     response :   *default_response", 
            "title": "reusing test specification"
        }, 
        {
            "location": "/features/#retrying-failed-tests", 
            "text": "Sometimes a resource takes a bit of time to get to a state you expect, for instance when you are polling a job status and it goes \nto completed state after a while. In such cases, you would want to retry hitting the same request few times.   If you see below sample, response specification says expect 200 status code. If the response validation fails then Just-API attempts to retry the request if you have specified a  retry  attribute.\nHere the request will be attempted 3 times denoted by  count  with 10ms wait before each attempt.  wait_before_each  is an optional attribute to specify how many milliseconds you want to wait before each attempt.     -   name :   retry example \n     request : \n       path :   /retryPath \n       method :   get \n     retry : \n       count :   3 \n       wait_before_each :   10 \n     response : \n       status_code :   200", 
            "title": "Retrying failed tests"
        }, 
        {
            "location": "/features/#looping", 
            "text": "You can use the loop construct to loop through a list of items, each item generating a test.  The list of items can be specified in spec beforehand or you can specify a custom JS function which returns a list of items.  Here's how a static loop is specified,  type  is static and loop list is mapped to  static  field as list of items.\nYou will have access to that item in before_test hook by accessing  this.loopItem .     -   name :   static loop test \n     loop : \n       type :   static \n       static : \n         -   2 \n         -   3 \n     before_test : \n       run_type :   inline \n       inline : \n         function :   !!js/function   \n           function() { \n             this.test.query_params = { limit : this.loopItem }; \n           } \n     request : \n       path :   /users \n       method :   get \n     response : \n       status_code :   200   There's another way to provide a list of items, with  dynamic  type and a custom JS function.     -   name :   dynamic loop test \n     loop : \n       type :   dynamic \n       dynamic : \n         run_type :   inline \n         inline : \n           function :   !!js/function    \n             function() { \n               return [2, 3]; \n             }            \n     before_test : \n       run_type :   inline \n       inline : \n         function :   !!js/function   \n           function() { \n             this.test.query_params = { limit : this.loopItem }; \n           }            \n     request : \n       path :   /users \n       method :   get \n     response : \n       status_code :   200   Note that if your loop has a list of n items, n tests will be generated at runtime.", 
            "title": "Looping"
        }, 
        {
            "location": "/features/#additional-features", 
            "text": "Following are some additional features offered by Just-API.", 
            "title": "Additional features"
        }, 
        {
            "location": "/features/#reports-test-duration", 
            "text": "Just-API reports duration of each test run in all formats of reports.", 
            "title": "reports test duration"
        }, 
        {
            "location": "/features/#running-only-tests-matching-with-a-given-patterntext", 
            "text": "If you want to run only specs matches with a given text or pattern, you can do so by using  --grep  option.  Following invocation will run all specs whose name matches with 'user' string.  ./node_modules/.bin/just-api --grep user specs", 
            "title": "running only tests matching with a given pattern/text"
        }, 
        {
            "location": "/features/#additional-request-options", 
            "text": "Following additional request options are supported.   followRedirect - follow HTTP 3xx responses as redirects.  followAllRedirects - follow non-GET HTTP 3xx responses as redirects.  followOriginalHttpMethod - by default we redirect to HTTP method GET. you can enable this property to redirect to the original HTTP method (default: false)  encoding - encoding to be used on setEncoding of response data. If null, the body is returned as a Buffer. \n   Anything else (including the default value of undefined) will be passed as the encoding parameter to toString() (meaning this is effectively utf8 by default). (Note: if you expect binary data, you should set encoding: null.)  gzip - if true, adds an Accept-Encoding header to request compressed content encodings from the server (if not already present) and decodes supported content encodings in the response.   A sample spec on how to specify these options:     -   name :   spec with redirection disabled \n     request :  \n       path :   /home \n       method :   get \n       additional_options : \n         followRedirect :   false \n         gzip :   true \n     response : \n       status_code :   200", 
            "title": "Additional request options"
        }, 
        {
            "location": "/features/#finding-suites-recursively", 
            "text": "When you want to run suites stored in a directory hierarchy spanning more than one nested level, you can invoke the Just-API with  --recursive  option.  ./node_modules/.bin/just-api --recursive specs", 
            "title": "Finding suites recursively"
        }, 
        {
            "location": "/features/#proper-error-reporting", 
            "text": "When a test or suite fails, Just-API provides the correct error, that caused the failure in reports.", 
            "title": "Proper error reporting"
        }, 
        {
            "location": "/features/#exit-code-for-ci-support", 
            "text": "Just-API exits with proper exit code, so you can use it in CI to determine the status of your tests.  Usually exit code is equal to number of failed suites unless some unexpected error occurs.", 
            "title": "Exit code for CI support"
        }, 
        {
            "location": "/features/#logging-http-requestresponse-data-for-failed-tests", 
            "text": "When a test with multiple dependencies fails it's hard to track which request has failed. To make failure tracking easy, Just-API allows you to ask for HTTP call details for failed tests. You would be able to see all HTTP calls made for a failed test in HTML or JSON report.  To enable this feature you need to invoke Just-API with  --reporter-options logRequests  ./node_modules/.bin/just-api --reporter html --reporter-options logRequests specs", 
            "title": "Logging HTTP request/response data for failed tests"
        }, 
        {
            "location": "/features/#no-callbacks", 
            "text": "You might have observed that there is no mention of callbacks anywhere. yes, Just-API does not support callback mechanism when running custom JS functions.\nThis is to encourage usage of promises for asynchronous operations.  When you are dealing with asynchronous tasks, wrap them in a async function and return a promise.", 
            "title": "No callbacks"
        }, 
        {
            "location": "/features/#running-suites-in-parallel", 
            "text": "See  page", 
            "title": "Running suites in parallel"
        }, 
        {
            "location": "/features/#reporters", 
            "text": "See  page", 
            "title": "Reporters"
        }, 
        {
            "location": "/running-suites-in-parallel/", 
            "text": "Executing suites in parallel\n\n\nWhen you have lots of test suites, it might take a while to execute all of them serially. \n\n\nTo reduce the test execution time, Just-API is built with parallelism. You can invoke just-api with \n--parallel\n option to trigger parallel execution mode.\nAll reporters respect parallel mode and generate correct reports with properly mapped errors if any.\n\n\nThis is how you can execute suites in parallel with just-api\n\n\n./node_modules/.bin/just-api --parallel \n8\n\n\n\n\n\n\nAbove command will start test execution in parallel mode with 8 suites at a time. \n\n\nNote\n: Maximum number of suites you can run in parallel is 24.", 
            "title": "Parallel exectuion"
        }, 
        {
            "location": "/running-suites-in-parallel/#executing-suites-in-parallel", 
            "text": "When you have lots of test suites, it might take a while to execute all of them serially.   To reduce the test execution time, Just-API is built with parallelism. You can invoke just-api with  --parallel  option to trigger parallel execution mode.\nAll reporters respect parallel mode and generate correct reports with properly mapped errors if any.  This is how you can execute suites in parallel with just-api  ./node_modules/.bin/just-api --parallel  8   Above command will start test execution in parallel mode with 8 suites at a time.   Note : Maximum number of suites you can run in parallel is 24.", 
            "title": "Executing suites in parallel"
        }, 
        {
            "location": "/reporters/", 
            "text": "Reporters\n\n\nGenerating a report\n\n\nJust-API has several built-in reporters, \njson\n, \nspecs\n, \nhtml\n etc.\n\n\nWhen you need a HTML report, you can invoke just-api with the \n--reporter\n option\n\n\n./node_modules/.bin/just-api --reporter html\n\n\n\n\n\nA sample html report:\n\n\n\n\nNotice that report has request, response details for the failed test\n\n\nGenerating reports in multiple formats\n\n\nJust-API can generate reports in multiple formats.\n\n\nWhen you need a HTML report and a JSON report too, you could do something like this\n\n\n./node_modules/.bin/just-api --reporter html,json\n\n\n\n\n\nThis way you can generate reports in multiple formats for the same run.\n\n\nCustom Reporters\n\n\nWhen built-in reporters do not provide the information you need, you can write a custom reporter and use it:\n\n\n./node_modules/.bin/just-api --reporter html,custom-reporter-module-name\n\n\n\n\n\nor if the reporter is local js file \n\n\n./node_modules/.bin/just-api --reporter html,/absolute/path/to/js/file\n\n\n\n\n\nReporters in Just-API are JavaScript constructors. When instantiated, a reporter receives the test launcher object  along with program options.\n\n\nJust-API emits events on launcher object and suite object, So a custom reporter should listen to these events and implement  reporting.\n\n\nFollowing events are emitted on the launcher object\n\n\n\n\nstart\n\n\nend\n\n\nnew suite (Indicates the start of a new suite)\n\n\n\n\nAnd below events are emitted on each suite object\n\n\n\n\ntest pass\n\n\ntest fail\n\n\ntest skip\n\n\nend (Indicates the end of a suite)\n\n\n\n\nIf you are looking to write a custom reporter, take a look at Just-API's \nJSON Reporter\n \n\n\nReporter options\n\n\nJust-API accepts an additonal command line option \n--reporter-options\n that you can use to customize how and where reports are generated and saved.\n\n\nYou must pass a comma separated list of key and value pairs to this option as \nk=v,k2=v2,...\n\n\nFollowing keys are supported currently.\n\n\n\n\njsonReportDir\n\n\njsonReportName\n\n\nhtmlReportDir\n\n\nhtmlReportName\n\n\nlogRequests\n\n\n\n\njsonReportDir\n: Provide an existing directory path that is relative to Just-API node process's cwd. JSON report will be saved to this directory.\n\n\nhtmlReportDir\n: Provide an existing directory path that is relative to Just-API node process's cwd. HTML report will be saved to this directory.\n\n\njsonReportName\n: Provide a name for the JSON report file. JSON report will be saved with this name.\n\n\nhtmlReportName\n: Provide a name for the HTML report file. HTML report will be saved with this name.\n\n\nlogRequests\n: Tells Just-API to log HTTP request \n response details in reports for failed tests. Omit this if you don't want to log details.\n\n\nA sample Just-API invocation would look like:\n\n\n./node_modules/.bin/just-api --reporter html,json --reporter-options \njsonReportDir\n=\nreports,jsonReportName\n=\njson-report,htmlReportDir\n=\nreports,htmlReportName\n=\nhtml-report,logRequests", 
            "title": "Reporters"
        }, 
        {
            "location": "/reporters/#reporters", 
            "text": "", 
            "title": "Reporters"
        }, 
        {
            "location": "/reporters/#generating-a-report", 
            "text": "Just-API has several built-in reporters,  json ,  specs ,  html  etc.  When you need a HTML report, you can invoke just-api with the  --reporter  option  ./node_modules/.bin/just-api --reporter html", 
            "title": "Generating a report"
        }, 
        {
            "location": "/reporters/#a-sample-html-report", 
            "text": "Notice that report has request, response details for the failed test", 
            "title": "A sample html report:"
        }, 
        {
            "location": "/reporters/#generating-reports-in-multiple-formats", 
            "text": "Just-API can generate reports in multiple formats.  When you need a HTML report and a JSON report too, you could do something like this  ./node_modules/.bin/just-api --reporter html,json  This way you can generate reports in multiple formats for the same run.", 
            "title": "Generating reports in multiple formats"
        }, 
        {
            "location": "/reporters/#custom-reporters", 
            "text": "When built-in reporters do not provide the information you need, you can write a custom reporter and use it:  ./node_modules/.bin/just-api --reporter html,custom-reporter-module-name  or if the reporter is local js file   ./node_modules/.bin/just-api --reporter html,/absolute/path/to/js/file  Reporters in Just-API are JavaScript constructors. When instantiated, a reporter receives the test launcher object  along with program options.  Just-API emits events on launcher object and suite object, So a custom reporter should listen to these events and implement  reporting.  Following events are emitted on the launcher object   start  end  new suite (Indicates the start of a new suite)   And below events are emitted on each suite object   test pass  test fail  test skip  end (Indicates the end of a suite)   If you are looking to write a custom reporter, take a look at Just-API's  JSON Reporter", 
            "title": "Custom Reporters"
        }, 
        {
            "location": "/reporters/#reporter-options", 
            "text": "Just-API accepts an additonal command line option  --reporter-options  that you can use to customize how and where reports are generated and saved.  You must pass a comma separated list of key and value pairs to this option as  k=v,k2=v2,...  Following keys are supported currently.   jsonReportDir  jsonReportName  htmlReportDir  htmlReportName  logRequests   jsonReportDir : Provide an existing directory path that is relative to Just-API node process's cwd. JSON report will be saved to this directory.  htmlReportDir : Provide an existing directory path that is relative to Just-API node process's cwd. HTML report will be saved to this directory.  jsonReportName : Provide a name for the JSON report file. JSON report will be saved with this name.  htmlReportName : Provide a name for the HTML report file. HTML report will be saved with this name.  logRequests : Tells Just-API to log HTTP request   response details in reports for failed tests. Omit this if you don't want to log details.  A sample Just-API invocation would look like:  ./node_modules/.bin/just-api --reporter html,json --reporter-options  jsonReportDir = reports,jsonReportName = json-report,htmlReportDir = reports,htmlReportName = html-report,logRequests", 
            "title": "Reporter options"
        }, 
        {
            "location": "/examples/", 
            "text": "Examples\n\n\nYou can find some examples on how to write test suites and tests in Just-API's test directory.\n\n\nJust-API itself is filled with lots of tests covering all supported features.\n\n\nPlease checkout test suites available \nhere\n\n\nTest suites available there should be able to help you write tests for your APIs.", 
            "title": "Examples"
        }, 
        {
            "location": "/examples/#examples", 
            "text": "You can find some examples on how to write test suites and tests in Just-API's test directory.  Just-API itself is filled with lots of tests covering all supported features.  Please checkout test suites available  here  Test suites available there should be able to help you write tests for your APIs.", 
            "title": "Examples"
        }
    ]
}