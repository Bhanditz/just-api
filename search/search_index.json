{
    "docs": [
        {
            "location": "/", 
            "text": "Just-API docs\n\n\n\n\nJust-API is a robust, specification based, codeless testing framework that tests \nREST\n, \nGraphQL\n (or any HTTP based) APIs.  It runs on \nnode.js\n. Just-API allows users to test APIs without writing code.\nJust-API takes API test specification from YAML files and runs them either in serial mode or in parallel mode as instructed by the user. It also reports errors and test results in several formats including HTML and JSON.\n\n\n\nIn simple terms, how it works is that you provide request and response validation specification in an yaml file. Just-API builds the request, makes a call to server\nand validates response as per the specification.\n\n\nYou can choose to validate any or all of response status code, headers, JSON data, JSON schema or provide your own custom validator function.\n\n\n\nContents\n\n\nDocumentation\n\n\n\n\nGetting Started\n\n\nBasic Concepts\n\n\nCLI\n\n\nFeatures\n\n\nReporters\n\n\nExamples\n\n\n\n\n\n\nFind it on npm\n\n\n\n\nStay In Touch\n\n\nTwitter\n\n\nFor an occasional update on what we're up to, follow us on Twitter.\n\n\nFollow @just_api_\n\n\nGithub\n\n\nStar Just-API on Github.\n\n\nStar\n\n\nGitter\n\n\nIf you are having problems with Just-API, have a question, or just want to say hello, you can chat with the community on gitter.\n\n\n\nGoogle group\n\n\nJust-API", 
            "title": "Home"
        }, 
        {
            "location": "/#just-api-docs", 
            "text": "Just-API is a robust, specification based, codeless testing framework that tests  REST ,  GraphQL  (or any HTTP based) APIs.  It runs on  node.js . Just-API allows users to test APIs without writing code.\nJust-API takes API test specification from YAML files and runs them either in serial mode or in parallel mode as instructed by the user. It also reports errors and test results in several formats including HTML and JSON.  \nIn simple terms, how it works is that you provide request and response validation specification in an yaml file. Just-API builds the request, makes a call to server\nand validates response as per the specification.  You can choose to validate any or all of response status code, headers, JSON data, JSON schema or provide your own custom validator function.", 
            "title": "Just-API docs"
        }, 
        {
            "location": "/#contents", 
            "text": "", 
            "title": "Contents"
        }, 
        {
            "location": "/#documentation", 
            "text": "Getting Started  Basic Concepts  CLI  Features  Reporters  Examples", 
            "title": "Documentation"
        }, 
        {
            "location": "/#find-it-on-npm", 
            "text": "", 
            "title": "Find it on npm"
        }, 
        {
            "location": "/#stay-in-touch", 
            "text": "", 
            "title": "Stay In Touch"
        }, 
        {
            "location": "/#twitter", 
            "text": "For an occasional update on what we're up to, follow us on Twitter.  Follow @just_api_", 
            "title": "Twitter"
        }, 
        {
            "location": "/#github", 
            "text": "Star Just-API on Github.  Star", 
            "title": "Github"
        }, 
        {
            "location": "/#gitter", 
            "text": "If you are having problems with Just-API, have a question, or just want to say hello, you can chat with the community on gitter.", 
            "title": "Gitter"
        }, 
        {
            "location": "/#google-group", 
            "text": "Just-API", 
            "title": "Google group"
        }, 
        {
            "location": "/getting-started/", 
            "text": "Installation\n\n\nInstall with \nnpm\n:\n\n\n$ npm install just-api\n\n\n\n\n\n\nTo run just-api, you will need Node.js v7.10.0 or newer.\n\n\n\n\nGetting Started\n\n\n$ npm install just-api\n$ mkdir specs\n$ $EDITOR specs/starwars_service.yml # or open with your preferred editor\n\n\n\n\nAPI test specification is written in yaml files, Enter below specification in the yaml file\n\n\nmeta:\n  name: Star Wars suite\nconfiguration:\n  scheme: https\n  host: swapi.co\n  base_path: /api\nspecs:\n  - name: get \nLuke Skywalker\n info\n    request:\n      path: /people/1/\n      method: get\n    response:\n      status_code: 200\n      json_data:\n        - path: $.name\n          value: Luke Skywalker\n\n\n\n\nBack in the terminal\n\n\n$ ./node_modules/.bin/just-api\n\n   \u2713 get Luke Skywalker info (1516ms)\n\n  Done: specs/suite.yml (Passed)\n\n0 skipped, 0 failed, 1 passed (1 tests)\n0 skipped, 0 failed, 1 passed (1 suites)\nDuration: 1.6s\n\n\n\n\nTesting GraphQL APIs\n\n\nFollowing example tests a GraphQL API that returns location for a given ip address.\n\n\nCreate the yaml suite file and run just-api.\n\n\nmeta:\n  name: GraphQL location service\nconfiguration:\n  host: api.graphloc.com\n  scheme: https\nspecs:\n  - name: Get Location of a an ip address\n    request:\n      method: post\n      path: /graphql\n      headers:\n        - name: content-type\n          value: application/json\n      payload:\n        body:\n          type: json\n          content:\n            query: \n\n                   {\n                    getLocation(ip: \n8.8.8.8\n) {\n                      country {\n                        iso_code\n                      }\n                     }\n                    }\n            variables: null\n            operationName: null\n    response:\n      status_code: 200\n      json_data:\n        - path: $.data.getLocation.country.iso_code\n          value: \nUS", 
            "title": "Getting Started"
        }, 
        {
            "location": "/getting-started/#installation", 
            "text": "Install with  npm :  $ npm install just-api   To run just-api, you will need Node.js v7.10.0 or newer.", 
            "title": "Installation"
        }, 
        {
            "location": "/getting-started/#getting-started", 
            "text": "$ npm install just-api\n$ mkdir specs\n$ $EDITOR specs/starwars_service.yml # or open with your preferred editor  API test specification is written in yaml files, Enter below specification in the yaml file  meta:\n  name: Star Wars suite\nconfiguration:\n  scheme: https\n  host: swapi.co\n  base_path: /api\nspecs:\n  - name: get  Luke Skywalker  info\n    request:\n      path: /people/1/\n      method: get\n    response:\n      status_code: 200\n      json_data:\n        - path: $.name\n          value: Luke Skywalker  Back in the terminal  $ ./node_modules/.bin/just-api\n\n   \u2713 get Luke Skywalker info (1516ms)\n\n  Done: specs/suite.yml (Passed)\n\n0 skipped, 0 failed, 1 passed (1 tests)\n0 skipped, 0 failed, 1 passed (1 suites)\nDuration: 1.6s", 
            "title": "Getting Started"
        }, 
        {
            "location": "/getting-started/#testing-graphql-apis", 
            "text": "Following example tests a GraphQL API that returns location for a given ip address.  Create the yaml suite file and run just-api.  meta:\n  name: GraphQL location service\nconfiguration:\n  host: api.graphloc.com\n  scheme: https\nspecs:\n  - name: Get Location of a an ip address\n    request:\n      method: post\n      path: /graphql\n      headers:\n        - name: content-type\n          value: application/json\n      payload:\n        body:\n          type: json\n          content:\n            query:  \n                   {\n                    getLocation(ip:  8.8.8.8 ) {\n                      country {\n                        iso_code\n                      }\n                     }\n                    }\n            variables: null\n            operationName: null\n    response:\n      status_code: 200\n      json_data:\n        - path: $.data.getLocation.country.iso_code\n          value:  US", 
            "title": "Testing GraphQL APIs"
        }, 
        {
            "location": "/basic-concepts/", 
            "text": "Basic Concepts\n\n\nThis section covers some high level basic concepts that are important to understand for day to day Just-API usage. We highly recommend that you read this\npage before proceeding to use Just-API.\n\n\nThe High-level View\n\n\nJust-API is a framework that you can use to run HTTP based API tests.\n\n\nYou write your API test specification and tell Just-API to run them. API test specifications are written in YAML and we call each YAML file a test suite, with the option to write Javascript (using any \nnpm\n module if needed) to write custom logic.\n\n\nJust-API's main purpose is to test HTTP based APIs without code, and make API testing easy, free and fast for everyone.\n\n\nJust-API is written with parallelism as priority while running suites, so your test execution takes as less time as possible.\n\n\nPutting a test suite together\n\n\nA test suite has three required sections - \nmeta\n, \nconfiguration\n and \nspecs\n.\n\n\nAnd optional sections \nhooks\n and \nspec_dependencies\n (you can find more about these optional parts in later sections of the documentation).\n\n\nThe \nmeta\n Section\n\n\nThis is where you specify \nname\n for the suite and other suite related metadata.\n\n\nThe \nconfiguration\n Section\n\n\nYou can use \nconfiguration\n section to specify API's host, scheme, port etc. you can also provide a custom Javascript function to \ncustom_configuration\n key, so it's easy to \ndynamically configure your suite at runtime.\n\n\nThe \nspecs\n Section\n\n\nspecs\n section is a list of tests. Each test contains name, request, response validation specification etc.\n\n\nAn Example Suite\n\n\nA sample suite for Star Wars API service would look like this:\n\n\nmeta:\n  name: Star Wars service\nconfiguration:\n  scheme: https\n  base_path: /api\n  custom_configuration:\n    run_type: inline\n    inline:\n      function: !!js/function \n\n        function() {\n          this.host = 'swapi.co';\n        }  \nspecs:\n  - name: get Luke Skywalker info\n    request: \n      path: /people/1/\n      method: get\n    response:\n      status_code: 200\n      json_data:\n        - path: $.name\n          value: Luke Skywalker     \n  - name: get all Star Wars Films\n    request: \n      path: /films/   \n      method: get\n    response:\n      status_code: 200  \n\n\n\n\nNext:\n\n\n\n\nSee the full set of features available in \nFeatures\n.\n\n\nLearn about  \nreports\n in \nReporters\n.", 
            "title": "Basic Concepts"
        }, 
        {
            "location": "/basic-concepts/#basic-concepts", 
            "text": "This section covers some high level basic concepts that are important to understand for day to day Just-API usage. We highly recommend that you read this\npage before proceeding to use Just-API.", 
            "title": "Basic Concepts"
        }, 
        {
            "location": "/basic-concepts/#the-high-level-view", 
            "text": "Just-API is a framework that you can use to run HTTP based API tests.  You write your API test specification and tell Just-API to run them. API test specifications are written in YAML and we call each YAML file a test suite, with the option to write Javascript (using any  npm  module if needed) to write custom logic.  Just-API's main purpose is to test HTTP based APIs without code, and make API testing easy, free and fast for everyone.  Just-API is written with parallelism as priority while running suites, so your test execution takes as less time as possible.", 
            "title": "The High-level View"
        }, 
        {
            "location": "/basic-concepts/#putting-a-test-suite-together", 
            "text": "A test suite has three required sections -  meta ,  configuration  and  specs .  And optional sections  hooks  and  spec_dependencies  (you can find more about these optional parts in later sections of the documentation).", 
            "title": "Putting a test suite together"
        }, 
        {
            "location": "/basic-concepts/#the-meta-section", 
            "text": "This is where you specify  name  for the suite and other suite related metadata.", 
            "title": "The meta Section"
        }, 
        {
            "location": "/basic-concepts/#the-configuration-section", 
            "text": "You can use  configuration  section to specify API's host, scheme, port etc. you can also provide a custom Javascript function to  custom_configuration  key, so it's easy to \ndynamically configure your suite at runtime.", 
            "title": "The configuration Section"
        }, 
        {
            "location": "/basic-concepts/#the-specs-section", 
            "text": "specs  section is a list of tests. Each test contains name, request, response validation specification etc.", 
            "title": "The specs Section"
        }, 
        {
            "location": "/basic-concepts/#an-example-suite", 
            "text": "A sample suite for Star Wars API service would look like this:  meta:\n  name: Star Wars service\nconfiguration:\n  scheme: https\n  base_path: /api\n  custom_configuration:\n    run_type: inline\n    inline:\n      function: !!js/function  \n        function() {\n          this.host = 'swapi.co';\n        }  \nspecs:\n  - name: get Luke Skywalker info\n    request: \n      path: /people/1/\n      method: get\n    response:\n      status_code: 200\n      json_data:\n        - path: $.name\n          value: Luke Skywalker     \n  - name: get all Star Wars Films\n    request: \n      path: /films/   \n      method: get\n    response:\n      status_code: 200    Next:   See the full set of features available in  Features .  Learn about   reports  in  Reporters .", 
            "title": "An Example Suite"
        }, 
        {
            "location": "/CLI/", 
            "text": "CLI Reference\n\n\nInvoke \njust-api\n from command-line\n\n\nUsage: just-api [options] [files]\n\nOptions:\n\n    -V, --version                       output the version number\n    --parallel \ninteger\n                specify the number of suites to be run in parallel\n    --reporter \nreporternames\n          specify the reporters to use, comma separated list e.g json,html\n    --reporter-options \nk=v,k2=v2,...\n  reporter-specific options\n    --grep \npattern\n                    only run tests matching \npattern\n\n    --recursive                         include sub directories when searching for suites\n    --reporters                         display available reporters\n    -h, --help                          output usage information", 
            "title": "CLI Reference"
        }, 
        {
            "location": "/CLI/#cli-reference", 
            "text": "Invoke  just-api  from command-line  Usage: just-api [options] [files]\n\nOptions:\n\n    -V, --version                       output the version number\n    --parallel  integer                 specify the number of suites to be run in parallel\n    --reporter  reporternames           specify the reporters to use, comma separated list e.g json,html\n    --reporter-options  k=v,k2=v2,...   reporter-specific options\n    --grep  pattern                     only run tests matching  pattern \n    --recursive                         include sub directories when searching for suites\n    --reporters                         display available reporters\n    -h, --help                          output usage information", 
            "title": "CLI Reference"
        }, 
        {
            "location": "/features/", 
            "text": "Just-API Features\n\n\nRequest Specification\n\n\nA typical request specification includes request path, headers, query params, path params, and payload (if applicable).\n\n\nRequest Methods\n\n\nJust-API supports following HTTP request methods. You can have a request specification which\nincludes any of these methods.\n\n\n\n\nGET\n\n\nPOST\n\n\nPUT\n\n\nPATCH\n\n\nDELETE\n\n\nHEAD\n\n\nOPTIONS\n\n\n\n\nNote that when a request is POST, PUT or PATCH, payload details can be provided and it will\nbe sent as request body. More on this in later sections.\n\n\nSpecifying Headers, Query params, Path params\n\n\nRequest headers can be specified to \nheaders\n key as list of name, value pair.\nRequest Query params can be specified to \nquery_params\n key as list of name, value pair.\nRequest Path params can be specified to \npath_params\n key as list of name, value pair.\n\n\nA sample test specification with method, headers, query params and path params:\n\n\n  - name: A sample test\n    request:\n       path: /user/{userId}/posts/{postId}\n       method: get\n       headers:\n         - name: Accept\n           value: application/json\n       path_params:\n          - name: userId\n            value: 12876\n          - name: postId\n            value: 92\n       query_params:\n          - name: limit\n            value: 10\n    response:\n       status_code: 200\n\n\n\n\nRequest Body Specification\n\n\nWhen you need to send body for POST, PUT and PATCH requests, you can specify the body to \npayload\n key.\n\n\nYou will need to specify \ncontent-type\n header and body \ntype\n as shown below\nHere's how to send JSON body with a POST request\n\n\n  - name: create a new user\n    request: \n      path: /users\n      method: post\n      headers:\n        - name: content-type\n          value: application/json\n      payload:\n          body:\n            type: json\n            content:\n              firstName: john\n              lastName: doe\n    response:\n      status_code: 201\n\n\n\n\nYou can also send binary data as body by reading from a file as shown below.\n\n\n  - name: post binary data (file) as body\n    request:\n      path: /uploadImage\n      method: post\n      headers:\n        - name: content-type\n          value: image/png\n      payload:\n          body:\n            type: binary\n            content: static/assets/image.png\n    response:\n      status_code: 200\n\n\n\n\nNote that the image path should be relative to process's current working directory.\n\n\nPlease checkout more examples on how to specify request body \nhere\n\n\nForm, multipart requests, file uploads\n\n\nJust-API supports \nx-www-form-urlencoded\n and \nmultipart/form-data\n requests using which you can upload files and perform tests on complex requests.\n\n\nspecify \nx-www-form-urlencoded\n request\n\n\nTo create a \nx-www-form-urlencoded\n request test, you will need to specify the \ncontent-type\n header and form body like below:\n\n\nNote that \npayload\n should have a key \nform\n and it should contain form data in key value pairs.\n\n\n  - name: Authenticate a user\n    request:\n      path: /authenticate\n      method: post\n      headers:\n        - name: content-type\n          value: application/x-www-form-urlencoded\n      payload:\n          form:\n            userName: john.doe\n            password: john.doe.password\n    response:\n      status_code: 200\n\n\n\n\nMore examples on \nx-www-form-urlencoded\n tests can be found \nhere\n\n\nspecify \nmultipart/form-data\n request\n\n\nHere's how you can specify a multipart request.\n\n\nNote that \npayload\n should have a key \nform_data\n and it should contain list of form data fields.\n\n\n  - name: post multipart form data - single file and field\n    request:\n      path: /imageNText\n      method: post\n      headers:\n        - name: content-type\n          value: multipart/form-data\n      payload:\n          form_data:\n            - name: image_name\n              content: static/assets/logo.png\n              type: file\n            - name: field1\n              content: value1\n              type: text\n    response:\n      status_code: 200\n\n\n\n\nMore examples on \nmultipart/form-data\n tests can be found \nhere\n\n\nResponse Validation\n\n\nJust-API allows you to validate responses without writing any code, you can validate following in a response by specifying what to validate.\n\n\n\n\nStatus code\n\n\nHeaders\n\n\nJSON schema\n\n\nJSON body\n\n\n\n\nYou can also have a custom validator function that will validate the response.\n\n\nStatus code validation\n\n\nYou can provide \nstatus_code\n attribute in response and Just-API matches actual response's Status code against the specification.\nTest will fail when actual response's Status code does not match with specified value.\n\n\nA sample:\n\n\n  - name: get users\n    request:\n      path: /users\n      method: get\n    response:\n      status_code: 400\n\n\n\n\nHeaders validation\n\n\nWhen you specify headers in response, Just-API will validate response headers against your specification.\n\n\nA sample on how to specify headers validation.\n\n\n  - name: get users\n    request:\n      path: /users\n      method: get\n    response:\n      headers:\n        - name: content-type\n          value: application/json\n\n\n\n\nYou can even match header against a regex instead of exact value, like below:\n\n\nFollowing response specification would check if response header \ncontent-type\n matches with regex pattern \n'json'\n.\n\n\n  - name: get users\n    request:\n      path: /users\n      method: get\n    response:\n      headers:\n        - name: content-type\n          value: !!js/regexp json\n\n\n\n\nMore examples on response header validation can be found \nhere\n\n\nResponse JSON schema validation\n\n\nSome times you may want to validate the schema of JSON received in response's body, which will allow you to ensure that server is sending data exactly what you are expecting.\n\n\nwith Just-API, you can validate the response JSON schema by specifying the \njson_schema\n attribute in response.\n\n\nFollowing sample shows how to read expected schema from a file and validate response JSON body against it. Here json_schema has two fields, \ntype\n key can be either file or inline.\nWhen \ntype\n is file, you need to provide the relative path to schema file to \n$ref\n key.\n\n\n  - name: get users\n    request: \n      path: /users\n      method: get\n    response:\n      json_schema:\n          type: file\n          $ref: static/schema/expected_schema_for_users.json\n\n\n\n\nYou can also specify expected JSON schema in yaml by setting type as \ninline\n and assigning a string to \n$ref\n like below:\n\n\n  - name: get users\n    request: \n      path: /users\n      method: get\n    response:\n      json_schema:\n          type: inline\n          $ref: \n\n                {\n                  \n$id\n: \nhttp://example.com/example.json\n,\n                  \ntype\n: \nobject\n,\n                  \n$schema\n: \nhttp://json-schema.org/draft-06/schema#\n,\n                  \nproperties\n: {\n                    \nfirstName\n: {\n                      \n$id\n: \n/properties/firstName\n,\n                      \ntype\n: \nstring\n\n                    }\n                  }\n                }\n\n\n\n\nIf you are not sure about JSON schema standard, Please refer to \nJSON schema\n\n\nMore examples on response JSON schema validation can be found \nhere\n\n\nResponse JSON body validation\n\n\nWhen you want to validate one or many fields of response JSON, you can do so by providing \njson_data\n as part of response specification.\n\n\njson_data\n should have a list of pair of path \n value, where path tells Just-API how to locate the field, and value is the expected value for that field.\n\n\nFollowing sample shows that.\n\n\n  - name: get users\n    request: \n      path: /users\n      method: get\n    response:\n      json_data:\n        - path: $.[0].firstName\n          value: john\n\n\n\n\nIf you are not sure on how to generate JSON path, Please refer to \nJSON path\n\n\nMore examples on response JSON data validation can be found \nhere\n\n\nUser defined custom response validator functions\n\n\nWhen you need to validate a response using your custom logic, you can do so by providing a \ninline\n or \nmodule\n custom javascript function to \ncustom_validator\n attribute.\n\n\nJust-API will invoke the custom function by passing the response to function's this context, so you can access the response using \nthis.response\n: \n\n\nHere's a sample on how to specify a custom inline Javascript function to validate the response\n\n\n  - name: get users\n    request:\n      path: /users\n      method: get\n    response:\n      status_code: 200\n      custom_validator:\n        run_type: inline\n        inline:\n          function: !!js/function \n\n            function() {\n              var body = JSON.parse(this.response.body);\n\n              if (body.users[0].firstName !== 'john')\n                  throw new Error(\nfirst user's name is not john\n);\n            }\n\n\n\n\nYou can also specify a custom function defined and exported in a module by providing \nrun_type\n as module and module path like below.\n\n\n  - name: get users\n    request:\n      path: /users\n      method: get\n    response:\n      status_code: 200\n      custom_validator:\n        run_type: module\n        module:\n          module_path: modules/custom_module.js\n          function_name: validateUsersResponse\n\n\n\n\nMore examples on validating response using custom functions can be found \nhere\n\n\nCustom Javascript functions\n\n\nJust-API allows users to specify custom Javascript functions for (hooks and custom validator).\n\n\nThese custom Javascript function can be inline or defined in a module. They can synchronous or asynchronous defined with (async keyword). \n\n\ncutom inline and module functions\n\n\ncustom inline function\n\n\nAn \ninline\n synchronous function is defined as below.\n\n\n  custom_validator:\n    run_type: inline\n    inline:\n      function: !!js/function \n\n        function() {\n          // some custom code here...\n        }\n\n\n\n\nNote that run_type is \ninline\n and function is mapped to function key of \ninline\n attribute. \n!!js/function\n is how you tell Just-API parse to consider it as custom synchronous functions.\n\n\ncustom module function\n\n\nA \nmodule\n synchronous function is specified as below.\n\n\n custom_validator:\n   run_type: module\n   module:\n     module_path: modules/custom_module.js\n     function_name: customFunctionName\n\n\n\n\nNote that run_type is \nmodule\n and function details are mapped to \nmodule\n attribute. \nmodule_path\n has the relative path to the JS file.\nThe JS file is expected to be a standard Node.js module.\n\nfunction_name\n is the function exported in the module.\n\n\nAsync support for custom functions with promises\n\n\nCustom functions can be asynchronous defined with async keyword, Just-API waits until promise returned by function is resolved or rejected.\n\n\nAn \ninline\n asynchronous function is defined as below.\n\n\n  custom_validator:\n    run_type: inline\n    inline:\n      function: !js/asyncFunction \n\n        async function() {\n          // some custom asynchrounous code here...\n        }\n\n\n\n\nNote that run_type is \ninline\n and function is mapped to function key of \ninline\n attribute. \n!js/asyncFunction\n is how you tell Just-API parse to consider it as custom asynchronous functions.\n\n\nA \nmodule\n asynchronous function is specified as below.\n\n\n custom_validator:\n   run_type: module\n   module:\n     module_path: modules/custom_module.js\n     function_name: customAsyncFunctionName\n\n\n\n\nNote that run_type is \nmodule\n and function details are mapped to \nmodule\n attribute. \nmodule_path\n has the relative path to the JS file.The JS file is expected to be a standard Node.js module.\n\nfunction_name\n is the async function defined async keyword in the module.\n\n\nSuite configuration\n\n\nWhen you are running tests, you would want to configure API host, port etc according to the environment you are testing against.\n\n\nIn order to facilitate this, Just-API provides a \nconfiguration\n section in each suite, where you can have a \ncustom_configuration\n attribute \nand provide a custom JS function to set suite configuration.\n\n\nHere's an example to do that with an inline custom JS function.\n\n\nconfiguration:\n  scheme: https\n  custom_configuration:\n    run_type: inline\n    inline:\n      function: !!js/function \n\n        function() {\n          if (process.env.TEST_ENVIRONMENT === 'Dev') {\n             this.host = 'dev-host.com'\n          }\n\n          if (process.env.TEST_ENVIRONMENT === 'QA') { \n            this.host = 'qa-host.com';\n          }\n        }\n\n\n\n\nyou can also have a module based custom JS function to configure the suite.\n\n\nNote that \ncustom_configuration\n is optional. you can always specify static suite configuration if test environment details does not change for you.\n\n\nconfiguration:\n  scheme: https\n  host: testhost.com\n  port: 8000\n  base_path: /api\n\n\n\n\nMore examples \nhere\n\n\nHooks\n\n\nIf you are familiar with mocha, you might have used hooks. Just-API supports following hooks so it's easy setup your tests.\n\n\nSuite specific hooks\n\n\nThese can be specified as part of \nhooks\n attribute.\n\n\n\n\nBefore all  (runs before all specs in a suite)\n\n\nAfter all   (runs after all specs in a suite)\n\n\nBefore each  (runs before each spec in a suite )\n\n\nAfter each  (runs after each passed spec in a suite )\n\n\n\n\nTest specific hooks\n\n\nThese can be specified for each as required.\n\n\n\n\nBefore test  (runs before a spec, you can use this hook to setup test prerequisites )\n\n\nAfter test  (runs after a passed spec, you can use this hook to teardown/clear any test specific data  )\n\n\n\n\nCheckout some samples of hooks \nhere\n\n\nDynamic request construction\n\n\nStatic specification of request is not possible for all sort of test. Sometimes a test depends on data returned by another request, where you would want \nto run the dependency spec first and fetch required data from it and pass it on to request. To handle usecases like this, Just-API provides a\n\nbefore_test\n hook for every test. Using this hook you can run test prerequisites and update request data for actual test.\n\n\nTypically we need to build dynamic requests when a request depends on the data received from another request. In such cases, you \ncan run the dependency spec in before_test hook and use the response to build the actual request for test.\n\n\nHeaders\n\n\nUpdating or overriding request headers in before test:\n\n\n  - name: send headers specified in before test hook\n    before_test:\n      run_type: inline\n      inline:\n        function: !!js/function \n\n          function() {\n            this.test.headers = { Authorization: 'some token' };\n          }\n    request:\n      path: /users\n      method: get\n    response:\n      status_code: 200\n\n\n\n\nQuery params\n\n\nUpdating or overriding request query params in before test:\n\n\n  - name: Query params added in hook\n    before_test:\n      run_type: inline\n      inline:\n        function: !!js/function \n\n          function() {\n            this.test.query_params = { limit: 10 };\n          }\n    request:\n       path: /users\n       method: get\n    response:\n       status_code: 200\n\n\n\n\nPath params\n\n\nUpdating or overriding request Path params in before test:\n\n\n  - name: path params added in hook\n    before_test:\n      run_type: inline\n      inline:\n        function: !!js/function \n\n          function() {\n            this.test.path_params = { id: 1 };\n          }\n    request:\n       path: /user/{id}\n       method: get\n    response:\n       status_code: 200\n\n\n\n\nBody\n\n\nYou can also define request payload at runtime using hooks\n\n\n  - name: Payload defined in hook\n    before_test:\n      run_type: inline\n      inline:\n        function: !!js/function \n\n          function() {\n            this.test.payload = { body: {type: 'json', content: { firstName: 'john',\n             lastName: 'doe'}} };\n          }\n    request:\n       path: /users\n       method: post\n       headers:\n         - name: content-type\n           value: application/json\n    response:\n       status_code: 201\n\n\n\n\nCustom context\n\n\nYou will have access to suite context and test context in hooks, So you can use them as a way to store custom data to use in later hooks.\n\n\nSuite context can be accessed in hooks using \nthis.suite\n.\nTest context can be accessed in test specific hooks using 'this.test'.\n\n\nStoring suite \n test data in context for reuse\n\n\nWhen you have some data that you want to use later in some tests, you can store the data into suite context in \nbefore_all\n hook.\n\n\n  before_all:\n    run_type: inline\n    inline:\n      function: !!js/function \n\n        function() {\n           this.suite.serviceSecret = 'secret';\n        }\n\n\n\n\nand later when you need the secret in a test, you can access it in before_test hook.\n\n\n  - name: using suite context in before test hook\n    before_test:\n      run_type: inline\n      inline:\n        function: !!js/function \n\n          function() {\n              this.test.headers = { Authorization: this.suite.serviceSecret };\n          }\n    request:\n      path: /users\n      method: get\n    response: \n      status_code: 200\n\n\n\n\nSimilarly you can set test context in before_test hook using \nthis.test\n and access it using `this.test' in after_test hook.\n\n\nSpec dependencies\n\n\nThis is probably one of best features of Just-API.\n\n\nJust-API allows testing APIs in flow, where one request depends on response data from another request. This is really useful when you are\ntesting complex transaction APIs etc.\n\n\nRunning dependencies\n\n\nRunning pre-requisite requests can be done using hooks. There is \nbefore_each\n and \nbefore_test\n hooks.\n\n\nIf you have a dependency specific to a test, then you might want to use \nbefore_test\n hook to run the dependecy spec.\n\n\nThere is support for 2 types of dependencies, \nIntrasuite\n \n \nIntersuite\n spec.\n\n\nYou will need to first provide dependency specification so that you can run it from other specs.\n\n\nIntrasuite spec dependencies\n\n\nIntrasuite dependency is when you have a dependency that is specified in the same suite. You can then run the dependency by\nusing \nthis.runSpec()\n in a hook. runSpec function takes 2 arguments. First argument is the name of your dependency spec and second argument\nis an object with additional information you want to pass to the request such as headers, query params, path params, and body.\n\n\nFollowing set of specs show how to run dependencies as part of a test and use the data for subsequent requests.\n\n\nspecs:\n  - name: thisis the dependency\n    enabled: false\n    request:\n      path: /token\n      method: get\n    response:\n      status_code: 200\n\n  - name: actual test spec\n    before_test:\n      run_type: inline\n      inline:\n        function: !js/asyncFunction \n\n          async function() {\n            var response = await this.runSpec('thisis the dependency');\n            var tokenResponse = JSON.parse(response.body);\n            this.test.headers = {Authorization:  tokenResponse.token};\n          }\n    request:\n      path: /users\n      method: get\n    response:\n      status_code: 200\n\n\n\n\nIntersuite spec dependencies\n\n\nIntersuite is when you have a dependency that is specified in the another suite but you import it using \nspec_dependencies\n construct.\n\n\nRunning Intersuite dependency is similar to running Intrasuite dependency.\n\n\nYou can import specs defined in another by specifying relative path to the suite.\n\n\nspec_dependencies:\n  - suites/anothersuite.yml\n\n\n\n\nAnd you can import specs from multiple suites by listing their relative paths.\n\n\nNote that these imported specs will only be available when you run them using \nthis.runSpec\n.\n\n\nPlease find some examples on dependencies \nhere\n\n\nSkipping\n\n\nYou can explicitly skip suites and tests with specification.\n\n\nSkipping a suite\n\n\nWhen you have written a suite in a directory, but want to skip running it for some reason, you can do so by providing\n  \nfalse\n as value for enabled key under \nmeta\n in a suite, Just-API will skip the suite.\n\n\n meta:\n  name: Disabled sute\n  enabled: false\nconfiguration:\n  scheme: http\n  host: 127.0.0.1\nspecs:\n  - name: get users\n    request:\n      path: /users\n      method: get\n    response:\n      status_code: 200\n\n\n\n\nNote that if any error occurs before Just-API reads \nmeta\n info of the suite, then suite will be marked as failure.\n\n\nSkipping a test\n\n\nWhen you written a set of specs in a suite, but want to skip a spec, you can do so by providing \nfalse\n as value for enabled key of the spec.\n\n\n  - name: disabled spec\n    enabled: false\n    request:\n      path: /\n      method: get\n    response:\n      status_code: 200\n\n\n\n\nJust-API will mark the spec as a skipped test.\n\n\nreusing test specification\n\n\nApart from readability, an awesome thing about yaml is that you can reuse parts of your specification.\n\n\nRefer to \ndry\n to see how you can reuse stuff in yaml.\n\n\nyou can see how response specification is being reused below\n\n\nmeta:\n  name: suite name\nconfiguration:\n  scheme: http\n  host: example.com\nspecs:\n  - name: get user1\n    request:\n      path: /users/1\n      method: get\n    response: \ndefault_response\n      status_code: 200\n\n  - name: get user2\n    request: \ndefault_request\n      path: /users/1\n      method: get\n    response: *default_response\n\n\n\n\nRetrying failed tests\n\n\nSometimes a resource takes a bit of time to get to a state you expect, for instance when you are polling a job status and it goes \nto completed state after a while. In such cases, you would want to retry hitting the same request few times. \n\n\nIf you see below sample, response validation says expect 200 status code. If the response validation fails then Just-API attempt to retry the request\nif you have specified \nretry\n attribute.\nHere the request is attempted 3 times denoted by \ncount\n with 10ms wait before each attempt.\n\n\nwait_before_each\n is an optional attribute to specify how many milliseconds you want to wait before each attempt.\n\n\n  - name: retry example\n    request:\n      path: /retryPath\n      method: get\n    retry:\n      count: 3\n      wait_before_each: 10\n    response:\n      status_code: 200\n\n\n\n\nLooping\n\n\nYou can use the loop construct to loop through a list of items, each item generating a test.\n\n\nThe list of items can be specified in spec beforehand or you can specify a custom JS function which returns a list of items.\n\n\nHere's how a static loop is specified, \ntype\n is static and loop list is mapped to \nstatic\n field as list of items.\nYou will have access to that item in before_test hook by accessing \nthis.loopItem\n.\n\n\n  - name: static loop test\n    loop:\n      type: static\n      static:\n        - 2\n        - 3\n    before_test:\n      run_type: inline\n      inline:\n        function: !!js/function \n\n          function() {\n            this.test.query_params = { limit : this.loopItem };\n          }\n    request:\n      path: /users\n      method: get\n    response:\n      status_code: 200\n\n\n\n\nThere's another way to provide a list of items, with \ndynamic\n type and a custom JS function.\n\n\n  - name: dynamic loop test\n    loop:\n      type: dynamic\n      dynamic:\n        run_type: inline\n        inline:\n          function: !!js/function  \n\n            function() {\n              return [2, 3];\n            }           \n    before_test:\n      run_type: inline\n      inline:\n        function: !!js/function \n\n          function() {\n            this.test.query_params = { limit : this.loopItem };\n          }           \n    request:\n      path: /users\n      method: get\n    response:\n      status_code: 200\n\n\n\n\nNote that if your loop has a list of n items, n tests will be generated at runtime.\n\n\nAdditional features\n\n\nFollowing are some additional features offered by Just-API.\n\n\nreports test duration\n\n\nJust-API includes duration of each test run in all formats of reports.\n\n\nrunning only tests match with a given pattern/text\n\n\nIf you want to run only specs matches with a given text or pattern, you can do so by using \n--grep\n option.\n\n\nFollowing invocation will run all specs whose name matches with 'user' string.\n\n\n./node_modules/.bin/just-api --grep user specs\n\n\n\n\nadditional request options\n\n\nFollowing additional request options are supported.\n\n\n\n\nfollowRedirect - follow HTTP 3xx responses as redirects.\n\n\nfollowAllRedirects - follow non-GET HTTP 3xx responses as redirects.\n\n\nfollowOriginalHttpMethod - by default we redirect to HTTP method GET. you can enable this property to redirect to the original HTTP method (default: false)\n\n\nencoding - encoding to be used on setEncoding of response data. If null, the body is returned as a Buffer. \n   Anything else (including the default value of undefined) will be passed as the encoding parameter to toString() (meaning this is effectively utf8 by default). (Note: if you expect binary data, you should set encoding: null.)\n\n\ngzip - if true, add an Accept-Encoding header to request compressed content encodings from the server (if not already present) and decode supported content encodings in the response.\n\n\n\n\nA sample spec on how to specify these options:\n\n\n  - name: spec with redirection disabled\n    request: \n      path: /home\n      method: get\n      additional_options:\n        followRedirect: false\n    response:\n      status_code: 200\n\n\n\n\nFinding suites recursively\n\n\nWhen you want to run suites stored in a directory hierarchy spanning more than one nested level, you can invoke the Just-API with \n--recursive\n option.\n\n\n./node_modules/.bin/just-api --recursive specs\n\n\n\n\nProper error reporting\n\n\nWhen a test or suite fails, Just-API provides the correct error, that caused the failure in reports.\n\n\nExit code for CI support\n\n\nJust-API exits with proper exit code, so you can use it in CI to determine the status of your tests.\n\n\nUsually exit code is equal to number of failed suite unless some unexpected error occurs.\n\n\nLogging HTTP request/response data for failed tests\n\n\nWhen a test with multiple dependencies fails it's hard to track which request has failed. To make failure tracking easy, Just-API allows you to \nask for HTTP call details for failed tests. You would be able to see all HTTP calls made for a failed test n HTML or JSON report.\n\n\nTo enable this feature you need to invoke Just-API with \n--reporter-options logRequests\n\n\n./node_modules/.bin/just-api --reporter html --reporter-options logRequests specs\n\n\n\n\nNo callbacks\n\n\nYou might have observed that there is mention of callbacks anywhere. yes, Just-API does not support callback mechanism when running custom JS functions.\nThis is to encourage usage of promises for asynchronous operations.\n\n\nWhen you are dealing with asynchronous tasks, wrap them in an async function.\n\n\nRunning suites in parallel\n\n\nPlease see \npage\n \n\n\nReporters\n\n\nPlease see \npage", 
            "title": "Just-API Features"
        }, 
        {
            "location": "/features/#just-api-features", 
            "text": "", 
            "title": "Just-API Features"
        }, 
        {
            "location": "/features/#request-specification", 
            "text": "A typical request specification includes request path, headers, query params, path params, and payload (if applicable).", 
            "title": "Request Specification"
        }, 
        {
            "location": "/features/#request-methods", 
            "text": "Just-API supports following HTTP request methods. You can have a request specification which\nincludes any of these methods.   GET  POST  PUT  PATCH  DELETE  HEAD  OPTIONS   Note that when a request is POST, PUT or PATCH, payload details can be provided and it will\nbe sent as request body. More on this in later sections.", 
            "title": "Request Methods"
        }, 
        {
            "location": "/features/#specifying-headers-query-params-path-params", 
            "text": "Request headers can be specified to  headers  key as list of name, value pair.\nRequest Query params can be specified to  query_params  key as list of name, value pair.\nRequest Path params can be specified to  path_params  key as list of name, value pair.  A sample test specification with method, headers, query params and path params:    - name: A sample test\n    request:\n       path: /user/{userId}/posts/{postId}\n       method: get\n       headers:\n         - name: Accept\n           value: application/json\n       path_params:\n          - name: userId\n            value: 12876\n          - name: postId\n            value: 92\n       query_params:\n          - name: limit\n            value: 10\n    response:\n       status_code: 200", 
            "title": "Specifying Headers, Query params, Path params"
        }, 
        {
            "location": "/features/#request-body-specification", 
            "text": "When you need to send body for POST, PUT and PATCH requests, you can specify the body to  payload  key.  You will need to specify  content-type  header and body  type  as shown below\nHere's how to send JSON body with a POST request    - name: create a new user\n    request: \n      path: /users\n      method: post\n      headers:\n        - name: content-type\n          value: application/json\n      payload:\n          body:\n            type: json\n            content:\n              firstName: john\n              lastName: doe\n    response:\n      status_code: 201  You can also send binary data as body by reading from a file as shown below.    - name: post binary data (file) as body\n    request:\n      path: /uploadImage\n      method: post\n      headers:\n        - name: content-type\n          value: image/png\n      payload:\n          body:\n            type: binary\n            content: static/assets/image.png\n    response:\n      status_code: 200  Note that the image path should be relative to process's current working directory.  Please checkout more examples on how to specify request body  here", 
            "title": "Request Body Specification"
        }, 
        {
            "location": "/features/#form-multipart-requests-file-uploads", 
            "text": "Just-API supports  x-www-form-urlencoded  and  multipart/form-data  requests using which you can upload files and perform tests on complex requests.", 
            "title": "Form, multipart requests, file uploads"
        }, 
        {
            "location": "/features/#specify-x-www-form-urlencoded-request", 
            "text": "To create a  x-www-form-urlencoded  request test, you will need to specify the  content-type  header and form body like below:  Note that  payload  should have a key  form  and it should contain form data in key value pairs.    - name: Authenticate a user\n    request:\n      path: /authenticate\n      method: post\n      headers:\n        - name: content-type\n          value: application/x-www-form-urlencoded\n      payload:\n          form:\n            userName: john.doe\n            password: john.doe.password\n    response:\n      status_code: 200  More examples on  x-www-form-urlencoded  tests can be found  here", 
            "title": "specify x-www-form-urlencoded request"
        }, 
        {
            "location": "/features/#specify-multipartform-data-request", 
            "text": "Here's how you can specify a multipart request.  Note that  payload  should have a key  form_data  and it should contain list of form data fields.    - name: post multipart form data - single file and field\n    request:\n      path: /imageNText\n      method: post\n      headers:\n        - name: content-type\n          value: multipart/form-data\n      payload:\n          form_data:\n            - name: image_name\n              content: static/assets/logo.png\n              type: file\n            - name: field1\n              content: value1\n              type: text\n    response:\n      status_code: 200  More examples on  multipart/form-data  tests can be found  here", 
            "title": "specify multipart/form-data request"
        }, 
        {
            "location": "/features/#response-validation", 
            "text": "Just-API allows you to validate responses without writing any code, you can validate following in a response by specifying what to validate.   Status code  Headers  JSON schema  JSON body   You can also have a custom validator function that will validate the response.", 
            "title": "Response Validation"
        }, 
        {
            "location": "/features/#status-code-validation", 
            "text": "You can provide  status_code  attribute in response and Just-API matches actual response's Status code against the specification.\nTest will fail when actual response's Status code does not match with specified value.  A sample:    - name: get users\n    request:\n      path: /users\n      method: get\n    response:\n      status_code: 400", 
            "title": "Status code validation"
        }, 
        {
            "location": "/features/#headers-validation", 
            "text": "When you specify headers in response, Just-API will validate response headers against your specification.  A sample on how to specify headers validation.    - name: get users\n    request:\n      path: /users\n      method: get\n    response:\n      headers:\n        - name: content-type\n          value: application/json  You can even match header against a regex instead of exact value, like below:  Following response specification would check if response header  content-type  matches with regex pattern  'json' .    - name: get users\n    request:\n      path: /users\n      method: get\n    response:\n      headers:\n        - name: content-type\n          value: !!js/regexp json  More examples on response header validation can be found  here", 
            "title": "Headers validation"
        }, 
        {
            "location": "/features/#response-json-schema-validation", 
            "text": "Some times you may want to validate the schema of JSON received in response's body, which will allow you to ensure that server is sending data exactly what you are expecting.  with Just-API, you can validate the response JSON schema by specifying the  json_schema  attribute in response.  Following sample shows how to read expected schema from a file and validate response JSON body against it. Here json_schema has two fields,  type  key can be either file or inline.\nWhen  type  is file, you need to provide the relative path to schema file to  $ref  key.    - name: get users\n    request: \n      path: /users\n      method: get\n    response:\n      json_schema:\n          type: file\n          $ref: static/schema/expected_schema_for_users.json  You can also specify expected JSON schema in yaml by setting type as  inline  and assigning a string to  $ref  like below:    - name: get users\n    request: \n      path: /users\n      method: get\n    response:\n      json_schema:\n          type: inline\n          $ref:  \n                {\n                   $id :  http://example.com/example.json ,\n                   type :  object ,\n                   $schema :  http://json-schema.org/draft-06/schema# ,\n                   properties : {\n                     firstName : {\n                       $id :  /properties/firstName ,\n                       type :  string \n                    }\n                  }\n                }  If you are not sure about JSON schema standard, Please refer to  JSON schema  More examples on response JSON schema validation can be found  here", 
            "title": "Response JSON schema validation"
        }, 
        {
            "location": "/features/#response-json-body-validation", 
            "text": "When you want to validate one or many fields of response JSON, you can do so by providing  json_data  as part of response specification.  json_data  should have a list of pair of path   value, where path tells Just-API how to locate the field, and value is the expected value for that field.  Following sample shows that.    - name: get users\n    request: \n      path: /users\n      method: get\n    response:\n      json_data:\n        - path: $.[0].firstName\n          value: john  If you are not sure on how to generate JSON path, Please refer to  JSON path  More examples on response JSON data validation can be found  here", 
            "title": "Response JSON body validation"
        }, 
        {
            "location": "/features/#user-defined-custom-response-validator-functions", 
            "text": "When you need to validate a response using your custom logic, you can do so by providing a  inline  or  module  custom javascript function to  custom_validator  attribute.  Just-API will invoke the custom function by passing the response to function's this context, so you can access the response using  this.response :   Here's a sample on how to specify a custom inline Javascript function to validate the response    - name: get users\n    request:\n      path: /users\n      method: get\n    response:\n      status_code: 200\n      custom_validator:\n        run_type: inline\n        inline:\n          function: !!js/function  \n            function() {\n              var body = JSON.parse(this.response.body);\n\n              if (body.users[0].firstName !== 'john')\n                  throw new Error( first user's name is not john );\n            }  You can also specify a custom function defined and exported in a module by providing  run_type  as module and module path like below.    - name: get users\n    request:\n      path: /users\n      method: get\n    response:\n      status_code: 200\n      custom_validator:\n        run_type: module\n        module:\n          module_path: modules/custom_module.js\n          function_name: validateUsersResponse  More examples on validating response using custom functions can be found  here", 
            "title": "User defined custom response validator functions"
        }, 
        {
            "location": "/features/#custom-javascript-functions", 
            "text": "Just-API allows users to specify custom Javascript functions for (hooks and custom validator).  These custom Javascript function can be inline or defined in a module. They can synchronous or asynchronous defined with (async keyword).", 
            "title": "Custom Javascript functions"
        }, 
        {
            "location": "/features/#cutom-inline-and-module-functions", 
            "text": "", 
            "title": "cutom inline and module functions"
        }, 
        {
            "location": "/features/#custom-inline-function", 
            "text": "An  inline  synchronous function is defined as below.    custom_validator:\n    run_type: inline\n    inline:\n      function: !!js/function  \n        function() {\n          // some custom code here...\n        }  Note that run_type is  inline  and function is mapped to function key of  inline  attribute.  !!js/function  is how you tell Just-API parse to consider it as custom synchronous functions.", 
            "title": "custom inline function"
        }, 
        {
            "location": "/features/#custom-module-function", 
            "text": "A  module  synchronous function is specified as below.   custom_validator:\n   run_type: module\n   module:\n     module_path: modules/custom_module.js\n     function_name: customFunctionName  Note that run_type is  module  and function details are mapped to  module  attribute.  module_path  has the relative path to the JS file.\nThe JS file is expected to be a standard Node.js module. function_name  is the function exported in the module.", 
            "title": "custom module function"
        }, 
        {
            "location": "/features/#async-support-for-custom-functions-with-promises", 
            "text": "Custom functions can be asynchronous defined with async keyword, Just-API waits until promise returned by function is resolved or rejected.  An  inline  asynchronous function is defined as below.    custom_validator:\n    run_type: inline\n    inline:\n      function: !js/asyncFunction  \n        async function() {\n          // some custom asynchrounous code here...\n        }  Note that run_type is  inline  and function is mapped to function key of  inline  attribute.  !js/asyncFunction  is how you tell Just-API parse to consider it as custom asynchronous functions.  A  module  asynchronous function is specified as below.   custom_validator:\n   run_type: module\n   module:\n     module_path: modules/custom_module.js\n     function_name: customAsyncFunctionName  Note that run_type is  module  and function details are mapped to  module  attribute.  module_path  has the relative path to the JS file.The JS file is expected to be a standard Node.js module. function_name  is the async function defined async keyword in the module.", 
            "title": "Async support for custom functions with promises"
        }, 
        {
            "location": "/features/#suite-configuration", 
            "text": "When you are running tests, you would want to configure API host, port etc according to the environment you are testing against.  In order to facilitate this, Just-API provides a  configuration  section in each suite, where you can have a  custom_configuration  attribute \nand provide a custom JS function to set suite configuration.  Here's an example to do that with an inline custom JS function.  configuration:\n  scheme: https\n  custom_configuration:\n    run_type: inline\n    inline:\n      function: !!js/function  \n        function() {\n          if (process.env.TEST_ENVIRONMENT === 'Dev') {\n             this.host = 'dev-host.com'\n          }\n\n          if (process.env.TEST_ENVIRONMENT === 'QA') { \n            this.host = 'qa-host.com';\n          }\n        }  you can also have a module based custom JS function to configure the suite.  Note that  custom_configuration  is optional. you can always specify static suite configuration if test environment details does not change for you.  configuration:\n  scheme: https\n  host: testhost.com\n  port: 8000\n  base_path: /api  More examples  here", 
            "title": "Suite configuration"
        }, 
        {
            "location": "/features/#hooks", 
            "text": "If you are familiar with mocha, you might have used hooks. Just-API supports following hooks so it's easy setup your tests.  Suite specific hooks  These can be specified as part of  hooks  attribute.   Before all  (runs before all specs in a suite)  After all   (runs after all specs in a suite)  Before each  (runs before each spec in a suite )  After each  (runs after each passed spec in a suite )   Test specific hooks  These can be specified for each as required.   Before test  (runs before a spec, you can use this hook to setup test prerequisites )  After test  (runs after a passed spec, you can use this hook to teardown/clear any test specific data  )   Checkout some samples of hooks  here", 
            "title": "Hooks"
        }, 
        {
            "location": "/features/#dynamic-request-construction", 
            "text": "Static specification of request is not possible for all sort of test. Sometimes a test depends on data returned by another request, where you would want \nto run the dependency spec first and fetch required data from it and pass it on to request. To handle usecases like this, Just-API provides a before_test  hook for every test. Using this hook you can run test prerequisites and update request data for actual test.  Typically we need to build dynamic requests when a request depends on the data received from another request. In such cases, you \ncan run the dependency spec in before_test hook and use the response to build the actual request for test.", 
            "title": "Dynamic request construction"
        }, 
        {
            "location": "/features/#headers", 
            "text": "Updating or overriding request headers in before test:    - name: send headers specified in before test hook\n    before_test:\n      run_type: inline\n      inline:\n        function: !!js/function  \n          function() {\n            this.test.headers = { Authorization: 'some token' };\n          }\n    request:\n      path: /users\n      method: get\n    response:\n      status_code: 200", 
            "title": "Headers"
        }, 
        {
            "location": "/features/#query-params", 
            "text": "Updating or overriding request query params in before test:    - name: Query params added in hook\n    before_test:\n      run_type: inline\n      inline:\n        function: !!js/function  \n          function() {\n            this.test.query_params = { limit: 10 };\n          }\n    request:\n       path: /users\n       method: get\n    response:\n       status_code: 200", 
            "title": "Query params"
        }, 
        {
            "location": "/features/#path-params", 
            "text": "Updating or overriding request Path params in before test:    - name: path params added in hook\n    before_test:\n      run_type: inline\n      inline:\n        function: !!js/function  \n          function() {\n            this.test.path_params = { id: 1 };\n          }\n    request:\n       path: /user/{id}\n       method: get\n    response:\n       status_code: 200", 
            "title": "Path params"
        }, 
        {
            "location": "/features/#body", 
            "text": "You can also define request payload at runtime using hooks    - name: Payload defined in hook\n    before_test:\n      run_type: inline\n      inline:\n        function: !!js/function  \n          function() {\n            this.test.payload = { body: {type: 'json', content: { firstName: 'john',\n             lastName: 'doe'}} };\n          }\n    request:\n       path: /users\n       method: post\n       headers:\n         - name: content-type\n           value: application/json\n    response:\n       status_code: 201", 
            "title": "Body"
        }, 
        {
            "location": "/features/#custom-context", 
            "text": "You will have access to suite context and test context in hooks, So you can use them as a way to store custom data to use in later hooks.  Suite context can be accessed in hooks using  this.suite .\nTest context can be accessed in test specific hooks using 'this.test'.", 
            "title": "Custom context"
        }, 
        {
            "location": "/features/#storing-suite-test-data-in-context-for-reuse", 
            "text": "When you have some data that you want to use later in some tests, you can store the data into suite context in  before_all  hook.    before_all:\n    run_type: inline\n    inline:\n      function: !!js/function  \n        function() {\n           this.suite.serviceSecret = 'secret';\n        }  and later when you need the secret in a test, you can access it in before_test hook.    - name: using suite context in before test hook\n    before_test:\n      run_type: inline\n      inline:\n        function: !!js/function  \n          function() {\n              this.test.headers = { Authorization: this.suite.serviceSecret };\n          }\n    request:\n      path: /users\n      method: get\n    response: \n      status_code: 200  Similarly you can set test context in before_test hook using  this.test  and access it using `this.test' in after_test hook.", 
            "title": "Storing suite &amp; test data in context for reuse"
        }, 
        {
            "location": "/features/#spec-dependencies", 
            "text": "This is probably one of best features of Just-API.  Just-API allows testing APIs in flow, where one request depends on response data from another request. This is really useful when you are\ntesting complex transaction APIs etc.", 
            "title": "Spec dependencies"
        }, 
        {
            "location": "/features/#running-dependencies", 
            "text": "Running pre-requisite requests can be done using hooks. There is  before_each  and  before_test  hooks.  If you have a dependency specific to a test, then you might want to use  before_test  hook to run the dependecy spec.  There is support for 2 types of dependencies,  Intrasuite     Intersuite  spec.  You will need to first provide dependency specification so that you can run it from other specs.", 
            "title": "Running dependencies"
        }, 
        {
            "location": "/features/#intrasuite-spec-dependencies", 
            "text": "Intrasuite dependency is when you have a dependency that is specified in the same suite. You can then run the dependency by\nusing  this.runSpec()  in a hook. runSpec function takes 2 arguments. First argument is the name of your dependency spec and second argument\nis an object with additional information you want to pass to the request such as headers, query params, path params, and body.  Following set of specs show how to run dependencies as part of a test and use the data for subsequent requests.  specs:\n  - name: thisis the dependency\n    enabled: false\n    request:\n      path: /token\n      method: get\n    response:\n      status_code: 200\n\n  - name: actual test spec\n    before_test:\n      run_type: inline\n      inline:\n        function: !js/asyncFunction  \n          async function() {\n            var response = await this.runSpec('thisis the dependency');\n            var tokenResponse = JSON.parse(response.body);\n            this.test.headers = {Authorization:  tokenResponse.token};\n          }\n    request:\n      path: /users\n      method: get\n    response:\n      status_code: 200", 
            "title": "Intrasuite spec dependencies"
        }, 
        {
            "location": "/features/#intersuite-spec-dependencies", 
            "text": "Intersuite is when you have a dependency that is specified in the another suite but you import it using  spec_dependencies  construct.  Running Intersuite dependency is similar to running Intrasuite dependency.  You can import specs defined in another by specifying relative path to the suite.  spec_dependencies:\n  - suites/anothersuite.yml  And you can import specs from multiple suites by listing their relative paths.  Note that these imported specs will only be available when you run them using  this.runSpec .  Please find some examples on dependencies  here", 
            "title": "Intersuite spec dependencies"
        }, 
        {
            "location": "/features/#skipping", 
            "text": "You can explicitly skip suites and tests with specification.", 
            "title": "Skipping"
        }, 
        {
            "location": "/features/#skipping-a-suite", 
            "text": "When you have written a suite in a directory, but want to skip running it for some reason, you can do so by providing\n   false  as value for enabled key under  meta  in a suite, Just-API will skip the suite.   meta:\n  name: Disabled sute\n  enabled: false\nconfiguration:\n  scheme: http\n  host: 127.0.0.1\nspecs:\n  - name: get users\n    request:\n      path: /users\n      method: get\n    response:\n      status_code: 200  Note that if any error occurs before Just-API reads  meta  info of the suite, then suite will be marked as failure.", 
            "title": "Skipping a suite"
        }, 
        {
            "location": "/features/#skipping-a-test", 
            "text": "When you written a set of specs in a suite, but want to skip a spec, you can do so by providing  false  as value for enabled key of the spec.    - name: disabled spec\n    enabled: false\n    request:\n      path: /\n      method: get\n    response:\n      status_code: 200  Just-API will mark the spec as a skipped test.", 
            "title": "Skipping a test"
        }, 
        {
            "location": "/features/#reusing-test-specification", 
            "text": "Apart from readability, an awesome thing about yaml is that you can reuse parts of your specification.  Refer to  dry  to see how you can reuse stuff in yaml.  you can see how response specification is being reused below  meta:\n  name: suite name\nconfiguration:\n  scheme: http\n  host: example.com\nspecs:\n  - name: get user1\n    request:\n      path: /users/1\n      method: get\n    response:  default_response\n      status_code: 200\n\n  - name: get user2\n    request:  default_request\n      path: /users/1\n      method: get\n    response: *default_response", 
            "title": "reusing test specification"
        }, 
        {
            "location": "/features/#retrying-failed-tests", 
            "text": "Sometimes a resource takes a bit of time to get to a state you expect, for instance when you are polling a job status and it goes \nto completed state after a while. In such cases, you would want to retry hitting the same request few times.   If you see below sample, response validation says expect 200 status code. If the response validation fails then Just-API attempt to retry the request\nif you have specified  retry  attribute.\nHere the request is attempted 3 times denoted by  count  with 10ms wait before each attempt.  wait_before_each  is an optional attribute to specify how many milliseconds you want to wait before each attempt.    - name: retry example\n    request:\n      path: /retryPath\n      method: get\n    retry:\n      count: 3\n      wait_before_each: 10\n    response:\n      status_code: 200", 
            "title": "Retrying failed tests"
        }, 
        {
            "location": "/features/#looping", 
            "text": "You can use the loop construct to loop through a list of items, each item generating a test.  The list of items can be specified in spec beforehand or you can specify a custom JS function which returns a list of items.  Here's how a static loop is specified,  type  is static and loop list is mapped to  static  field as list of items.\nYou will have access to that item in before_test hook by accessing  this.loopItem .    - name: static loop test\n    loop:\n      type: static\n      static:\n        - 2\n        - 3\n    before_test:\n      run_type: inline\n      inline:\n        function: !!js/function  \n          function() {\n            this.test.query_params = { limit : this.loopItem };\n          }\n    request:\n      path: /users\n      method: get\n    response:\n      status_code: 200  There's another way to provide a list of items, with  dynamic  type and a custom JS function.    - name: dynamic loop test\n    loop:\n      type: dynamic\n      dynamic:\n        run_type: inline\n        inline:\n          function: !!js/function   \n            function() {\n              return [2, 3];\n            }           \n    before_test:\n      run_type: inline\n      inline:\n        function: !!js/function  \n          function() {\n            this.test.query_params = { limit : this.loopItem };\n          }           \n    request:\n      path: /users\n      method: get\n    response:\n      status_code: 200  Note that if your loop has a list of n items, n tests will be generated at runtime.", 
            "title": "Looping"
        }, 
        {
            "location": "/features/#additional-features", 
            "text": "Following are some additional features offered by Just-API.", 
            "title": "Additional features"
        }, 
        {
            "location": "/features/#reports-test-duration", 
            "text": "Just-API includes duration of each test run in all formats of reports.", 
            "title": "reports test duration"
        }, 
        {
            "location": "/features/#running-only-tests-match-with-a-given-patterntext", 
            "text": "If you want to run only specs matches with a given text or pattern, you can do so by using  --grep  option.  Following invocation will run all specs whose name matches with 'user' string.  ./node_modules/.bin/just-api --grep user specs", 
            "title": "running only tests match with a given pattern/text"
        }, 
        {
            "location": "/features/#additional-request-options", 
            "text": "Following additional request options are supported.   followRedirect - follow HTTP 3xx responses as redirects.  followAllRedirects - follow non-GET HTTP 3xx responses as redirects.  followOriginalHttpMethod - by default we redirect to HTTP method GET. you can enable this property to redirect to the original HTTP method (default: false)  encoding - encoding to be used on setEncoding of response data. If null, the body is returned as a Buffer. \n   Anything else (including the default value of undefined) will be passed as the encoding parameter to toString() (meaning this is effectively utf8 by default). (Note: if you expect binary data, you should set encoding: null.)  gzip - if true, add an Accept-Encoding header to request compressed content encodings from the server (if not already present) and decode supported content encodings in the response.   A sample spec on how to specify these options:    - name: spec with redirection disabled\n    request: \n      path: /home\n      method: get\n      additional_options:\n        followRedirect: false\n    response:\n      status_code: 200", 
            "title": "additional request options"
        }, 
        {
            "location": "/features/#finding-suites-recursively", 
            "text": "When you want to run suites stored in a directory hierarchy spanning more than one nested level, you can invoke the Just-API with  --recursive  option.  ./node_modules/.bin/just-api --recursive specs", 
            "title": "Finding suites recursively"
        }, 
        {
            "location": "/features/#proper-error-reporting", 
            "text": "When a test or suite fails, Just-API provides the correct error, that caused the failure in reports.", 
            "title": "Proper error reporting"
        }, 
        {
            "location": "/features/#exit-code-for-ci-support", 
            "text": "Just-API exits with proper exit code, so you can use it in CI to determine the status of your tests.  Usually exit code is equal to number of failed suite unless some unexpected error occurs.", 
            "title": "Exit code for CI support"
        }, 
        {
            "location": "/features/#logging-http-requestresponse-data-for-failed-tests", 
            "text": "When a test with multiple dependencies fails it's hard to track which request has failed. To make failure tracking easy, Just-API allows you to \nask for HTTP call details for failed tests. You would be able to see all HTTP calls made for a failed test n HTML or JSON report.  To enable this feature you need to invoke Just-API with  --reporter-options logRequests  ./node_modules/.bin/just-api --reporter html --reporter-options logRequests specs", 
            "title": "Logging HTTP request/response data for failed tests"
        }, 
        {
            "location": "/features/#no-callbacks", 
            "text": "You might have observed that there is mention of callbacks anywhere. yes, Just-API does not support callback mechanism when running custom JS functions.\nThis is to encourage usage of promises for asynchronous operations.  When you are dealing with asynchronous tasks, wrap them in an async function.", 
            "title": "No callbacks"
        }, 
        {
            "location": "/features/#running-suites-in-parallel", 
            "text": "Please see  page", 
            "title": "Running suites in parallel"
        }, 
        {
            "location": "/features/#reporters", 
            "text": "Please see  page", 
            "title": "Reporters"
        }, 
        {
            "location": "/running-suites-in-parallel/", 
            "text": "Executing suites in parallel\n\n\nWhen you have lots of test suites, it might take a while to execute all of them serially. \nTo reduce the test execution time, Just-API is built with parallelism as high priority. You can invoke just-api with \n--parallel\n option to trigger parallel execution mode.\nAll reporters respect parallel mode and generate correct reports with properly mapped errors if any.\n\n\nThis is how you can execute suites in parallel with just-api\n\n\n./node_modules/.bin/just-api --parallel 8\n\n\n\n\nAbove command will start test execution in parallel mode with 8 suites at a time. \n\n\nNote\n: Maximum number of suites you can run in parallel is 24.", 
            "title": "Executing suites in parallel"
        }, 
        {
            "location": "/running-suites-in-parallel/#executing-suites-in-parallel", 
            "text": "When you have lots of test suites, it might take a while to execute all of them serially. \nTo reduce the test execution time, Just-API is built with parallelism as high priority. You can invoke just-api with  --parallel  option to trigger parallel execution mode.\nAll reporters respect parallel mode and generate correct reports with properly mapped errors if any.  This is how you can execute suites in parallel with just-api  ./node_modules/.bin/just-api --parallel 8  Above command will start test execution in parallel mode with 8 suites at a time.   Note : Maximum number of suites you can run in parallel is 24.", 
            "title": "Executing suites in parallel"
        }, 
        {
            "location": "/reporters/", 
            "text": "Reporters\n\n\nGenerating a report\n\n\nJust-API has several built-in reporters, \njson\n, 'specs', 'html' etc.\n\n\nWhen you need an HTML report, you can invoke just-api with the \n--reporter\n option\n\n\n./node_modules/.bin/just-api --reporter html\n\n\n\n\nGenerating reports in multiple formats\n\n\nJust-API has the ability to generate reports in multiple formats.\n\n\nWhen you need an HTML report and a JSON report too, you could do something like this\n\n\n./node_modules/.bin/just-api --reporter html,json\n\n\n\n\nThis way you can generate reports in multiple formats for the same run.", 
            "title": "Reporters"
        }, 
        {
            "location": "/reporters/#reporters", 
            "text": "", 
            "title": "Reporters"
        }, 
        {
            "location": "/reporters/#generating-a-report", 
            "text": "Just-API has several built-in reporters,  json , 'specs', 'html' etc.  When you need an HTML report, you can invoke just-api with the  --reporter  option  ./node_modules/.bin/just-api --reporter html", 
            "title": "Generating a report"
        }, 
        {
            "location": "/reporters/#generating-reports-in-multiple-formats", 
            "text": "Just-API has the ability to generate reports in multiple formats.  When you need an HTML report and a JSON report too, you could do something like this  ./node_modules/.bin/just-api --reporter html,json  This way you can generate reports in multiple formats for the same run.", 
            "title": "Generating reports in multiple formats"
        }, 
        {
            "location": "/examples/", 
            "text": "Examples\n\n\nYou can find some examples on how to write test suites and tests in Just-API's test directory.\n\n\nJust-API itself is filled with lots of tests covering all supported features.\n\n\nPlease checkout test suites available \nhere\n\n\nTest suites available there should be able to help you build tests for your APIs.", 
            "title": "Examples"
        }, 
        {
            "location": "/examples/#examples", 
            "text": "You can find some examples on how to write test suites and tests in Just-API's test directory.  Just-API itself is filled with lots of tests covering all supported features.  Please checkout test suites available  here  Test suites available there should be able to help you build tests for your APIs.", 
            "title": "Examples"
        }
    ]
}